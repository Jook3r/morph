# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `actioncable` gem.
# Please instead update this file by running `bin/tapioca gem actioncable`.

# source://actioncable-5.2.8.1/lib/action_cable/gem_version.rb:3
module ActionCable
  extend ::ActiveSupport::Autoload

  private

  # Singleton instance of the server
  #
  # source://actioncable-5.2.8.1/lib/action_cable.rb:45
  def server; end

  class << self
    # Returns the version of the currently loaded Action Cable as a <tt>Gem::Version</tt>.
    #
    # source://actioncable-5.2.8.1/lib/action_cable/gem_version.rb:5
    def gem_version; end

    # Singleton instance of the server
    #
    # source://actioncable-5.2.8.1/lib/action_cable.rb:45
    def server; end

    # Returns the version of the currently loaded Action Cable as a <tt>Gem::Version</tt>
    #
    # source://actioncable-5.2.8.1/lib/action_cable/version.rb:7
    def version; end
  end
end

# source://actioncable-5.2.8.1/lib/action_cable/channel.rb:4
module ActionCable::Channel
  extend ::ActiveSupport::Autoload
end

# The channel provides the basic structure of grouping behavior into logical units when communicating over the WebSocket connection.
# You can think of a channel like a form of controller, but one that's capable of pushing content to the subscriber in addition to simply
# responding to the subscriber's direct requests.
#
# Channel instances are long-lived. A channel object will be instantiated when the cable consumer becomes a subscriber, and then
# lives until the consumer disconnects. This may be seconds, minutes, hours, or even days. That means you have to take special care
# not to do anything silly in a channel that would balloon its memory footprint or whatever. The references are forever, so they won't be released
# as is normally the case with a controller instance that gets thrown away after every request.
#
# Long-lived channels (and connections) also mean you're responsible for ensuring that the data is fresh. If you hold a reference to a user
# record, but the name is changed while that reference is held, you may be sending stale data if you don't take precautions to avoid it.
#
# The upside of long-lived channel instances is that you can use instance variables to keep reference to objects that future subscriber requests
# can interact with. Here's a quick example:
#
#   class ChatChannel < ApplicationCable::Channel
#     def subscribed
#       @room = Chat::Room[params[:room_number]]
#     end
#
#     def speak(data)
#       @room.speak data, user: current_user
#     end
#   end
#
# The #speak action simply uses the Chat::Room object that was created when the channel was first subscribed to by the consumer when that
# subscriber wants to say something in the room.
#
# == Action processing
#
# Unlike subclasses of ActionController::Base, channels do not follow a RESTful
# constraint form for their actions. Instead, Action Cable operates through a
# remote-procedure call model. You can declare any public method on the
# channel (optionally taking a <tt>data</tt> argument), and this method is
# automatically exposed as callable to the client.
#
# Example:
#
#   class AppearanceChannel < ApplicationCable::Channel
#     def subscribed
#       @connection_token = generate_connection_token
#     end
#
#     def unsubscribed
#       current_user.disappear @connection_token
#     end
#
#     def appear(data)
#       current_user.appear @connection_token, on: data['appearing_on']
#     end
#
#     def away
#       current_user.away @connection_token
#     end
#
#     private
#       def generate_connection_token
#         SecureRandom.hex(36)
#       end
#   end
#
# In this example, the subscribed and unsubscribed methods are not callable methods, as they
# were already declared in ActionCable::Channel::Base, but <tt>#appear</tt>
# and <tt>#away</tt> are. <tt>#generate_connection_token</tt> is also not
# callable, since it's a private method. You'll see that appear accepts a data
# parameter, which it then uses as part of its model call. <tt>#away</tt>
# does not, since it's simply a trigger action.
#
# Also note that in this example, <tt>current_user</tt> is available because
# it was marked as an identifying attribute on the connection. All such
# identifiers will automatically create a delegation method of the same name
# on the channel instance.
#
# == Rejecting subscription requests
#
# A channel can reject a subscription request in the #subscribed callback by
# invoking the #reject method:
#
#   class ChatChannel < ApplicationCable::Channel
#     def subscribed
#       @room = Chat::Room[params[:room_number]]
#       reject unless current_user.can_access?(@room)
#     end
#   end
#
# In this example, the subscription will be rejected if the
# <tt>current_user</tt> does not have access to the chat room. On the
# client-side, the <tt>Channel#rejected</tt> callback will get invoked when
# the server rejects the subscription request.
#
# source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:96
class ActionCable::Channel::Base
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Channel::Callbacks
  include ::ActionCable::Channel::PeriodicTimers
  include ::ActionCable::Channel::Streams
  include ::ActionCable::Channel::Naming
  include ::ActionCable::Channel::Broadcasting
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Channel::Callbacks::ClassMethods
  extend ::ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::ActionCable::Channel::Naming::ClassMethods
  extend ::ActionCable::Channel::Broadcasting::ClassMethods

  # @return [Base] a new instance of Base
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:142
  def initialize(connection, identifier, params = T.unsafe(nil)); end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:124
  def __callbacks; end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:132
  def __callbacks?; end

  # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:815
  def _run_subscribe_callbacks(&block); end

  # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:815
  def _run_unsubscribe_callbacks(&block); end

  # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:827
  def _subscribe_callbacks; end

  # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:827
  def _unsubscribe_callbacks; end

  # Returns the value of attribute connection.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:103
  def connection; end

  # Returns the value of attribute identifier.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:103
  def identifier; end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:104
  def logger(*args, &block); end

  # Returns the value of attribute params.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:103
  def params; end

  # Extract the action name from the passed data and process it via the channel. The process will ensure
  # that the action requested is a public method on the channel declared by the user (so not one of the callbacks
  # like #subscribed).
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:162
  def perform_action(data); end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:136
  def periodic_timers=(val); end

  # This method is called after subscription has been added to the connection
  # and confirms or rejects the subscription.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:177
  def subscribe_to_channel; end

  # Called by the cable connection when it's cut, so the channel has a chance to cleanup with callbacks.
  # This method is not intended to be called directly by the user. Instead, overwrite the #unsubscribed callback.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:188
  def unsubscribe_from_channel; end

  private

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:272
  def action_signature(action, data); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:226
  def defer_subscription_confirmation!; end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:230
  def defer_subscription_confirmation?; end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:246
  def delegate_connection_identifiers; end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:262
  def dispatch_action(action, data); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:220
  def ensure_confirmation_sent; end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:254
  def extract_action(data); end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:258
  def processable_action?(action); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:238
  def reject; end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:291
  def reject_subscription; end

  # Called once a consumer has become a subscriber of the channel. Usually the place to setup any streams
  # you want this channel to be sending to the subscriber.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:197
  def subscribed; end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:234
  def subscription_confirmation_sent?; end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:242
  def subscription_rejected?; end

  # Transmit a hash of data to the subscriber. The hash will automatically be wrapped in a JSON envelope with
  # the proper channel identifier marked as the recipient.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:209
  def transmit(data, via: T.unsafe(nil)); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:280
  def transmit_subscription_confirmation; end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:296
  def transmit_subscription_rejection; end

  # Called once a consumer has cut its cable connection. Can be used for cleaning up connections or marking
  # users as offline or the like.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:203
  def unsubscribed; end

  class << self
    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:106
    def __callbacks; end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:104
    def __callbacks=(val); end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:99
    def __callbacks?; end

    # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:819
    def _subscribe_callbacks; end

    # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:823
    def _subscribe_callbacks=(value); end

    # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:819
    def _unsubscribe_callbacks; end

    # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:823
    def _unsubscribe_callbacks=(value); end

    # A list of method names that should be considered actions. This
    # includes all public instance methods on a channel, less
    # any internal methods (defined on Base), adding back in
    # any methods that are internal, but still exist on the class
    # itself.
    #
    # ==== Returns
    # * <tt>Set</tt> - A set of all methods that should be considered actions.
    #
    # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:115
    def action_methods; end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:106
    def periodic_timers; end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:104
    def periodic_timers=(val); end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:99
    def periodic_timers?; end

    private

    # action_methods are cached and there is sometimes need to refresh
    # them. ::clear_action_methods! allows you to do that, so next time
    # you run action_methods, they will be recalculated.
    #
    # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:131
    def clear_action_methods!; end

    # Refresh the cached action_methods when a new action_method is added.
    #
    # source://actioncable-5.2.8.1/lib/action_cable/channel/base.rb:136
    def method_added(name); end
  end
end

# source://actioncable-5.2.8.1/lib/action_cable/channel/broadcasting.rb:7
module ActionCable::Channel::Broadcasting
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionCable::Channel::Broadcasting::ClassMethods

  # source://actioncable-5.2.8.1/lib/action_cable/channel/broadcasting.rb:10
  def broadcasting_for(*args, &block); end
end

# source://actioncable-5.2.8.1/lib/action_cable/channel/broadcasting.rb:12
module ActionCable::Channel::Broadcasting::ClassMethods
  # Broadcast a hash to a unique broadcasting for this <tt>model</tt> in this channel.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/broadcasting.rb:14
  def broadcast_to(model, message); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/broadcasting.rb:18
  def broadcasting_for(model); end
end

# source://actioncable-5.2.8.1/lib/action_cable/channel/callbacks.rb:7
module ActionCable::Channel::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActionCable::Channel::Callbacks::ClassMethods

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

# source://actioncable-5.2.8.1/lib/action_cable/channel/callbacks.rb:16
module ActionCable::Channel::Callbacks::ClassMethods
  # source://actioncable-5.2.8.1/lib/action_cable/channel/callbacks.rb:21
  def after_subscribe(*methods, &block); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/callbacks.rb:30
  def after_unsubscribe(*methods, &block); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/callbacks.rb:17
  def before_subscribe(*methods, &block); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/callbacks.rb:26
  def before_unsubscribe(*methods, &block); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/callbacks.rb:21
  def on_subscribe(*methods, &block); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/callbacks.rb:30
  def on_unsubscribe(*methods, &block); end
end

# source://actioncable-5.2.8.1/lib/action_cable/channel/naming.rb:5
module ActionCable::Channel::Naming
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionCable::Channel::Naming::ClassMethods

  # source://actioncable-5.2.8.1/lib/action_cable/channel/naming.rb:22
  def channel_name(*args, &block); end
end

# source://actioncable-5.2.8.1/lib/action_cable/channel/naming.rb:8
module ActionCable::Channel::Naming::ClassMethods
  # Returns the name of the channel, underscored, without the <tt>Channel</tt> ending.
  # If the channel is in a namespace, then the namespaces are represented by single
  # colon separators in the channel name.
  #
  #   ChatChannel.channel_name # => 'chat'
  #   Chats::AppearancesChannel.channel_name # => 'chats:appearances'
  #   FooChats::BarAppearancesChannel.channel_name # => 'foo_chats:bar_appearances'
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/naming.rb:16
  def channel_name; end
end

# source://actioncable-5.2.8.1/lib/action_cable/channel/periodic_timers.rb:5
module ActionCable::Channel::PeriodicTimers
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionCable::Channel::PeriodicTimers::ClassMethods

  private

  # source://actioncable-5.2.8.1/lib/action_cable/channel/periodic_timers.rb:56
  def active_periodic_timers; end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/periodic_timers.rb:66
  def start_periodic_timer(callback, every:); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/periodic_timers.rb:60
  def start_periodic_timers; end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/periodic_timers.rb:72
  def stop_periodic_timers; end

  module GeneratedClassMethods
    def periodic_timers; end
    def periodic_timers=(value); end
    def periodic_timers?; end
  end

  module GeneratedInstanceMethods
    def periodic_timers=(value); end
  end
end

# source://actioncable-5.2.8.1/lib/action_cable/channel/periodic_timers.rb:15
module ActionCable::Channel::PeriodicTimers::ClassMethods
  # Periodically performs a task on the channel, like updating an online
  # user counter, polling a backend for new status messages, sending
  # regular "heartbeat" messages, or doing some internal work and giving
  # progress updates.
  #
  # Pass a method name or lambda argument or provide a block to call.
  # Specify the calling period in seconds using the <tt>every:</tt>
  # keyword argument.
  #
  #     periodically :transmit_progress, every: 5.seconds
  #
  #     periodically every: 3.minutes do
  #       transmit action: :update_count, count: current_count
  #     end
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/periodic_timers.rb:31
  def periodically(callback_or_method_name = T.unsafe(nil), every:, &block); end
end

# Streams allow channels to route broadcastings to the subscriber. A broadcasting is, as discussed elsewhere, a pubsub queue where any data
# placed into it is automatically sent to the clients that are connected at that time. It's purely an online queue, though. If you're not
# streaming a broadcasting at the very moment it sends out an update, you will not get that update, even if you connect after it has been sent.
#
# Most commonly, the streamed broadcast is sent straight to the subscriber on the client-side. The channel just acts as a connector between
# the two parties (the broadcaster and the channel subscriber). Here's an example of a channel that allows subscribers to get all new
# comments on a given page:
#
#   class CommentsChannel < ApplicationCable::Channel
#     def follow(data)
#       stream_from "comments_for_#{data['recording_id']}"
#     end
#
#     def unfollow
#       stop_all_streams
#     end
#   end
#
# Based on the above example, the subscribers of this channel will get whatever data is put into the,
# let's say, <tt>comments_for_45</tt> broadcasting as soon as it's put there.
#
# An example broadcasting for this channel looks like so:
#
#   ActionCable.server.broadcast "comments_for_45", author: 'DHH', content: 'Rails is just swell'
#
# If you have a stream that is related to a model, then the broadcasting used can be generated from the model and channel.
# The following example would subscribe to a broadcasting like <tt>comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE</tt>.
#
#   class CommentsChannel < ApplicationCable::Channel
#     def subscribed
#       post = Post.find(params[:id])
#       stream_for post
#     end
#   end
#
# You can then broadcast to this channel using:
#
#   CommentsChannel.broadcast_to(@post, @comment)
#
# If you don't just want to parlay the broadcast unfiltered to the subscriber, you can also supply a callback that lets you alter what is sent out.
# The below example shows how you can use this to provide performance introspection in the process:
#
#   class ChatChannel < ApplicationCable::Channel
#     def subscribed
#       @room = Chat::Room[params[:room_number]]
#
#       stream_for @room, coder: ActiveSupport::JSON do |message|
#         if message['originated_at'].present?
#           elapsed_time = (Time.now.to_f - message['originated_at']).round(2)
#
#           ActiveSupport::Notifications.instrument :performance, measurement: 'Chat.message_delay', value: elapsed_time, action: :timing
#           logger.info "Message took #{elapsed_time}s to arrive"
#         end
#
#         transmit message
#       end
#     end
#   end
#
# You can stop streaming from all broadcasts by calling #stop_all_streams.
#
# source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:65
module ActionCable::Channel::Streams
  extend ::ActiveSupport::Concern

  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:114
  def pubsub(*args, &block); end

  # Unsubscribes all streams associated with this channel from the pubsub queue.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:106
  def stop_all_streams; end

  # Start streaming the pubsub queue for the <tt>model</tt> in this channel. Optionally, you can pass a
  # <tt>callback</tt> that'll be used instead of the default of just transmitting the updates straight
  # to the subscriber.
  #
  # Pass <tt>coder: ActiveSupport::JSON</tt> to decode messages as JSON before passing to the callback.
  # Defaults to <tt>coder: nil</tt> which does no decoding, passes raw messages.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:101
  def stream_for(model, callback = T.unsafe(nil), coder: T.unsafe(nil), &block); end

  # Start streaming from the named <tt>broadcasting</tt> pubsub queue. Optionally, you can pass a <tt>callback</tt> that'll be used
  # instead of the default of just transmitting the updates straight to the subscriber.
  # Pass <tt>coder: ActiveSupport::JSON</tt> to decode messages as JSON before passing to the callback.
  # Defaults to <tt>coder: nil</tt> which does no decoding, passes raw messages.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:76
  def stream_from(broadcasting, callback = T.unsafe(nil), coder: T.unsafe(nil), &block); end

  private

  # May be overridden to change the default stream handling behavior
  # which decodes JSON and transmits to the client.
  #
  # TODO: Tests demonstrating this.
  #
  # TODO: Room for optimization. Update transmit API to be coder-aware
  # so we can no-op when pubsub and connection are both JSON-encoded.
  # Then we can skip decode+encode if we're just proxying messages.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:150
  def default_stream_handler(broadcasting, coder:); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:171
  def identity_handler; end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:155
  def stream_decoder(handler = T.unsafe(nil), coder:); end

  # May be overridden to add instrumentation, logging, specialized error
  # handling, or other forms of handler decoration.
  #
  # TODO: Tests demonstrating this.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:134
  def stream_handler(broadcasting, user_handler, coder: T.unsafe(nil)); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:163
  def stream_transmitter(handler = T.unsafe(nil), broadcasting:); end

  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:116
  def streams; end

  # Always wrap the outermost handler to invoke the user handler on the
  # worker pool rather than blocking the event loop.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/channel/streams.rb:122
  def worker_pool_stream_handler(broadcasting, user_handler, coder: T.unsafe(nil)); end
end

# source://actioncable-5.2.8.1/lib/action_cable/connection.rb:4
module ActionCable::Connection
  extend ::ActiveSupport::Autoload
end

# source://actioncable-5.2.8.1/lib/action_cable/connection/authorization.rb:5
module ActionCable::Connection::Authorization
  # Closes the \WebSocket connection if it is open and returns a 404 "File not Found" response.
  #
  # @raise [UnauthorizedError]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/authorization.rb:9
  def reject_unauthorized_connection; end
end

# source://actioncable-5.2.8.1/lib/action_cable/connection/authorization.rb:6
class ActionCable::Connection::Authorization::UnauthorizedError < ::StandardError; end

# For every WebSocket connection the Action Cable server accepts, a Connection object will be instantiated. This instance becomes the parent
# of all of the channel subscriptions that are created from there on. Incoming messages are then routed to these channel subscriptions
# based on an identifier sent by the Action Cable consumer. The Connection itself does not deal with any specific application logic beyond
# authentication and authorization.
#
# Here's a basic example:
#
#   module ApplicationCable
#     class Connection < ActionCable::Connection::Base
#       identified_by :current_user
#
#       def connect
#         self.current_user = find_verified_user
#         logger.add_tags current_user.name
#       end
#
#       def disconnect
#         # Any cleanup work needed when the cable connection is cut.
#       end
#
#       private
#         def find_verified_user
#           User.find_by_identity(cookies.encrypted[:identity_id]) ||
#             reject_unauthorized_connection
#         end
#     end
#   end
#
# First, we declare that this connection can be identified by its current_user. This allows us to later be able to find all connections
# established for that current_user (and potentially disconnect them). You can declare as many
# identification indexes as you like. Declaring an identification means that an attr_accessor is automatically set for that key.
#
# Second, we rely on the fact that the WebSocket connection is established with the cookies from the domain being sent along. This makes
# it easy to use signed cookies that were set when logging in via a web interface to authorize the WebSocket connection.
#
# Finally, we add a tag to the connection-specific logger with the name of the current user to easily distinguish their messages in the log.
#
# Pretty simple, eh?
#
# source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:45
class ActionCable::Connection::Base
  include ::ActionCable::Connection::Identification
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Authorization
  extend ::ActionCable::Connection::Identification::ClassMethods

  # @return [Base] a new instance of Base
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:53
  def initialize(server, env, coder: T.unsafe(nil)); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:118
  def beat; end

  # Close the WebSocket connection.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:98
  def close; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:85
  def dispatch_websocket_message(websocket_message); end

  # Returns the value of attribute env.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:50
  def env; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:51
  def event_loop(*args, &block); end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:124
  def identifiers; end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:136
  def identifiers=(val); end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:132
  def identifiers?; end

  # Returns the value of attribute logger.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:50
  def logger; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:135
  def on_close(reason, code); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:130
  def on_error(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:126
  def on_message(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:122
  def on_open; end

  # Called by the server when a new WebSocket connection is established. This configures the callbacks intended for overwriting by the user.
  # This method should not be called directly -- instead rely upon on the #connect (and #disconnect) callbacks.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:69
  def process; end

  # Returns the value of attribute protocol.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:50
  def protocol; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:51
  def pubsub(*args, &block); end

  # Decodes WebSocket messages and dispatches them to subscribed channels.
  # WebSocket message transfer encoding is always JSON.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:81
  def receive(websocket_message); end

  # Invoke a method on the connection asynchronously through the pool of thread workers.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:103
  def send_async(method, *arguments); end

  # Returns the value of attribute server.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:50
  def server; end

  # Return a basic hash of statistics for the connection keyed with <tt>identifier</tt>, <tt>started_at</tt>, <tt>subscriptions</tt>, and <tt>request_id</tt>.
  # This can be returned by a health check against the connection.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:109
  def statistics; end

  # Returns the value of attribute subscriptions.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:50
  def subscriptions; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:93
  def transmit(cable_message); end

  # Returns the value of attribute worker_pool.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:50
  def worker_pool; end

  protected

  # Returns the value of attribute message_buffer.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:143
  def message_buffer; end

  # Returns the value of attribute websocket.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:142
  def websocket; end

  private

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:197
  def allow_request_origin?; end

  # The cookies of the request that initiated the WebSocket connection. Useful for performing authorization checks.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:155
  def cookies; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:163
  def decode(websocket_message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:159
  def encode(cable_message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:239
  def finished_request_message; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:179
  def handle_close; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:167
  def handle_open; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:247
  def invalid_request_message; end

  # Tags are declared in the server but computed in the connection. This allows us per-connection tailored tags.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:225
  def new_tagged_logger; end

  # The request that initiated the WebSocket connection is available here. This gives access to the environment, cookies, etc.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:147
  def request; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:216
  def respond_to_invalid_request; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:211
  def respond_to_successful_request; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:190
  def send_welcome_message; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:230
  def started_request_message; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/base.rb:253
  def successful_request_message; end

  class << self
    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:106
    def identifiers; end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:104
    def identifiers=(val); end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:99
    def identifiers?; end
  end
end

# source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:11
class ActionCable::Connection::ClientSocket
  # @return [ClientSocket] a new instance of ClientSocket
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:34
  def initialize(env, event_target, event_loop, protocols); end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:112
  def alive?; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:108
  def client_gone; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:90
  def close(code = T.unsafe(nil), reason = T.unsafe(nil)); end

  # Returns the value of attribute env.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:32
  def env; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:104
  def parse(data); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:116
  def protocol; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:69
  def rack_response; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:57
  def start_driver; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:80
  def transmit(message); end

  # Returns the value of attribute url.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:32
  def url; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:74
  def write(data); end

  private

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:140
  def begin_close(reason, code); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:134
  def emit_error(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:149
  def finalize_close; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:121
  def open; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:128
  def receive_message(data); end

  class << self
    # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:12
    def determine_url(env); end

    # @return [Boolean]
    #
    # source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:17
    def secure_request?(env); end
  end
end

# source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:30
ActionCable::Connection::ClientSocket::CLOSED = T.let(T.unsafe(nil), Integer)

# source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:29
ActionCable::Connection::ClientSocket::CLOSING = T.let(T.unsafe(nil), Integer)

# source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:27
ActionCable::Connection::ClientSocket::CONNECTING = T.let(T.unsafe(nil), Integer)

# source://actioncable-5.2.8.1/lib/action_cable/connection/client_socket.rb:28
ActionCable::Connection::ClientSocket::OPEN = T.let(T.unsafe(nil), Integer)

# source://actioncable-5.2.8.1/lib/action_cable/connection/identification.rb:7
module ActionCable::Connection::Identification
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionCable::Connection::Identification::ClassMethods

  # Return a single connection identifier that combines the value of all the registered identifiers into a single gid.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/identification.rb:27
  def connection_identifier; end

  private

  # source://actioncable-5.2.8.1/lib/action_cable/connection/identification.rb:36
  def connection_gid(ids); end

  module GeneratedClassMethods
    def identifiers; end
    def identifiers=(value); end
    def identifiers?; end
  end

  module GeneratedInstanceMethods
    def identifiers; end
    def identifiers=(value); end
    def identifiers?; end
  end
end

# source://actioncable-5.2.8.1/lib/action_cable/connection/identification.rb:14
module ActionCable::Connection::Identification::ClassMethods
  # Mark a key as being a connection identifier index that can then be used to find the specific connection again later.
  # Common identifiers are current_user and current_account, but could be anything, really.
  #
  # Note that anything marked as an identifier will automatically create a delegate by the same name on any
  # channel instances created off the connection.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/identification.rb:20
  def identified_by(*identifiers); end
end

# Makes it possible for the RemoteConnection to disconnect a specific connection.
#
# source://actioncable-5.2.8.1/lib/action_cable/connection/internal_channel.rb:6
module ActionCable::Connection::InternalChannel
  extend ::ActiveSupport::Concern

  private

  # source://actioncable-5.2.8.1/lib/action_cable/connection/internal_channel.rb:10
  def internal_channel; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/internal_channel.rb:31
  def process_internal_message(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/internal_channel.rb:14
  def subscribe_to_internal_channel; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/internal_channel.rb:25
  def unsubscribe_from_internal_channel; end
end

# Allows us to buffer messages received from the WebSocket before the Connection has been fully initialized, and is ready to receive them.
#
# source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:6
class ActionCable::Connection::MessageBuffer
  # @return [MessageBuffer] a new instance of MessageBuffer
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:7
  def initialize(connection); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:12
  def append(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:28
  def process!; end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:24
  def processing?; end

  protected

  # Returns the value of attribute buffered_messages.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:37
  def buffered_messages; end

  # Returns the value of attribute connection.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:36
  def connection; end

  private

  # source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:48
  def buffer(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:44
  def receive(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:52
  def receive_buffered_messages; end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/message_buffer.rb:40
  def valid?(message); end
end

# source://actioncable-5.2.8.1/lib/action_cable/connection/stream.rb:11
class ActionCable::Connection::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream.rb:12
  def initialize(event_loop, socket); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream.rb:28
  def close; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream.rb:24
  def each(&callback); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream.rb:72
  def flush_write_buffer; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream.rb:98
  def hijack_rack_socket; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream.rb:94
  def receive(data); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream.rb:33
  def shutdown; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream.rb:37
  def write(data); end

  private

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream.rb:108
  def clean_rack_hijack; end
end

# source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:8
class ActionCable::Connection::StreamEventLoop
  # @return [StreamEventLoop] a new instance of StreamEventLoop
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:9
  def initialize; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:29
  def attach(io, stream); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:37
  def detach(io, stream); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:22
  def post(task = T.unsafe(nil), &block); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:55
  def stop; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:18
  def timer(interval, &block); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:46
  def writes_pending(io); end

  private

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:85
  def run; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:61
  def spawn; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/stream_event_loop.rb:81
  def wakeup; end
end

# Collection class for all the channel subscriptions established on a given connection. Responsible for routing incoming commands that arrive on
# the connection to the proper channel.
#
# source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:9
class ActionCable::Connection::Subscriptions
  # @return [Subscriptions] a new instance of Subscriptions
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:10
  def initialize(connection); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:27
  def add(data); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:15
  def execute_command(data); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:58
  def identifiers; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:72
  def logger(*args, &block); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:54
  def perform_action(data); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:44
  def remove(data); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:49
  def remove_subscription(subscription); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:62
  def unsubscribe_from_all; end

  protected

  # Returns the value of attribute connection.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:69
  def connection; end

  # Returns the value of attribute subscriptions.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:69
  def subscriptions; end

  private

  # source://actioncable-5.2.8.1/lib/action_cable/connection/subscriptions.rb:74
  def find(data); end
end

# Allows the use of per-connection tags against the server logger. This wouldn't work using the traditional
# <tt>ActiveSupport::TaggedLogging</tt> enhanced Rails.logger, as that logger will reset the tags between requests.
# The connection is long-lived, so it needs its own set of tags for its independent duration.
#
# source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:8
class ActionCable::Connection::TaggedLoggerProxy
  # @return [TaggedLoggerProxy] a new instance of TaggedLoggerProxy
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:11
  def initialize(logger, tags:); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:16
  def add_tags(*tags); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:31
  def debug(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:31
  def error(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:31
  def fatal(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:31
  def info(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:21
  def tag(logger); end

  # Returns the value of attribute tags.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:9
  def tags; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:31
  def unknown(message); end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:31
  def warn(message); end

  private

  # source://actioncable-5.2.8.1/lib/action_cable/connection/tagged_logger_proxy.rb:37
  def log(type, message); end
end

# Wrap the real socket to minimize the externally-presented API
#
# source://actioncable-5.2.8.1/lib/action_cable/connection/web_socket.rb:8
class ActionCable::Connection::WebSocket
  # @return [WebSocket] a new instance of WebSocket
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/web_socket.rb:9
  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/web_socket.rb:17
  def alive?; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/web_socket.rb:25
  def close; end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/web_socket.rb:13
  def possible?; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/web_socket.rb:29
  def protocol; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/web_socket.rb:33
  def rack_response; end

  # source://actioncable-5.2.8.1/lib/action_cable/connection/web_socket.rb:21
  def transmit(data); end

  protected

  # Returns the value of attribute websocket.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/connection/web_socket.rb:40
  def websocket; end
end

# source://actioncable-5.2.8.1/lib/action_cable/engine.rb:9
class ActionCable::Engine < ::Rails::Engine; end

# source://actioncable-5.2.8.1/lib/action_cable/helpers/action_cable_helper.rb:4
module ActionCable::Helpers; end

# source://actioncable-5.2.8.1/lib/action_cable/helpers/action_cable_helper.rb:5
module ActionCable::Helpers::ActionCableHelper
  # Returns an "action-cable-url" meta tag with the value of the URL specified in your
  # configuration. Ensure this is above your JavaScript tag:
  #
  #   <head>
  #     <%= action_cable_meta_tag %>
  #     <%= javascript_include_tag 'application', 'data-turbolinks-track' => 'reload' %>
  #   </head>
  #
  # This is then used by Action Cable to determine the URL of your WebSocket server.
  # Your CoffeeScript can then connect to the server without needing to specify the
  # URL directly:
  #
  #   #= require cable
  #   @App = {}
  #   App.cable = Cable.createConsumer()
  #
  # Make sure to specify the correct server location in each of your environment
  # config files:
  #
  #   config.action_cable.mount_path = "/cable123"
  #   <%= action_cable_meta_tag %> would render:
  #   => <meta name="action-cable-url" content="/cable123" />
  #
  #   config.action_cable.url = "ws://actioncable.com"
  #   <%= action_cable_meta_tag %> would render:
  #   => <meta name="action-cable-url" content="ws://actioncable.com" />
  #
  # source://actioncable-5.2.8.1/lib/action_cable/helpers/action_cable_helper.rb:33
  def action_cable_meta_tag; end
end

# source://actioncable-5.2.8.1/lib/action_cable.rb:33
ActionCable::INTERNAL = T.let(T.unsafe(nil), Hash)

# If you need to disconnect a given connection, you can go through the
# RemoteConnections. You can find the connections you're looking for by
# searching for the identifier declared on the connection. For example:
#
#   module ApplicationCable
#     class Connection < ActionCable::Connection::Base
#       identified_by :current_user
#       ....
#     end
#   end
#
#   ActionCable.server.remote_connections.where(current_user: User.find(1)).disconnect
#
# This will disconnect all the connections established for
# <tt>User.find(1)</tt>, across all servers running on all machines, because
# it uses the internal channel that all of these servers are subscribed to.
#
# source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:22
class ActionCable::RemoteConnections
  # @return [RemoteConnections] a new instance of RemoteConnections
  #
  # source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:25
  def initialize(server); end

  # Returns the value of attribute server.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:23
  def server; end

  # source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:29
  def where(identifier); end
end

# Represents a single remote connection found via <tt>ActionCable.server.remote_connections.where(*)</tt>.
# Exists solely for the purpose of calling #disconnect on that connection.
#
# source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:36
class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Identification
  extend ::ActionCable::Connection::Identification::ClassMethods

  # @return [RemoteConnection] a new instance of RemoteConnection
  #
  # source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:41
  def initialize(server, ids); end

  # Uses the internal channel to disconnect the connection.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:47
  def disconnect; end

  # source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:52
  def identifiers; end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:136
  def identifiers=(val); end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:132
  def identifiers?; end

  protected

  # Returns the value of attribute server.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:57
  def server; end

  private

  # @raise [InvalidIdentifiersError]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:60
  def set_identifier_instance_vars(ids); end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:65
  def valid_identifiers?(ids); end

  class << self
    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:106
    def identifiers; end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:104
    def identifiers=(val); end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:99
    def identifiers?; end
  end
end

# source://actioncable-5.2.8.1/lib/action_cable/remote_connections.rb:37
class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError < ::StandardError; end

# source://actioncable-5.2.8.1/lib/action_cable/server.rb:4
module ActionCable::Server
  extend ::ActiveSupport::Autoload
end

# A singleton ActionCable::Server instance is available via ActionCable.server. It's used by the Rack process that starts the Action Cable server, but
# is also used by the user to reach the RemoteConnections object, which is used for finding and disconnecting connections across all servers.
#
# Also, this is the server instance used for broadcasting. See Broadcasting for more information.
#
# source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:11
class ActionCable::Server::Base
  include ::ActionCable::Server::Broadcasting
  include ::ActionCable::Server::Connections

  # @return [Base] a new instance of Base
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:22
  def initialize; end

  # Called by Rack to setup the server.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:28
  def call(env); end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/module/attribute_accessors.rb:67
  def config; end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/module/attribute_accessors.rb:134
  def config=(obj); end

  # All of the identifiers applied to the connection class associated with this server.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:82
  def connection_identifiers; end

  # Disconnect all the connections identified by +identifiers+ on this server or any others via RemoteConnections.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:34
  def disconnect(identifiers); end

  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:57
  def event_loop; end

  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:18
  def logger(*args, &block); end

  # Returns the value of attribute mutex.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:20
  def mutex; end

  # Adapter used for all streams/broadcasting.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:77
  def pubsub; end

  # Gateway to RemoteConnections. See that class for details.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:53
  def remote_connections; end

  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:38
  def restart; end

  # The worker pool is where we run connection callbacks and channel actions. We do as little as possible on the server's main thread.
  # The worker pool is an executor service that's backed by a pool of threads working from a task queue. The thread pool size maxes out
  # at 4 worker threads by default. Tune the size yourself with <tt>config.action_cable.worker_pool_size</tt>.
  #
  # Using Active Record, Redis, etc within your channel actions means you'll get a separate connection from each thread in the worker pool.
  # Plan your deployment accordingly: 5 servers each running 5 Puma workers each running an 8-thread worker pool means at least 200 database
  # connections.
  #
  # Also, ensure that your database connection pool size is as least as large as your worker pool size. Otherwise, workers may oversubscribe
  # the database connection pool and block while they wait for other workers to release their connections. Use a smaller worker pool or a larger
  # database connection pool instead.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:72
  def worker_pool; end

  class << self
    # source://activesupport-5.2.8.1/lib/active_support/core_ext/module/attribute_accessors.rb:60
    def config; end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/module/attribute_accessors.rb:127
    def config=(obj); end

    # source://actioncable-5.2.8.1/lib/action_cable/server/base.rb:17
    def logger; end
  end
end

# Broadcasting is how other parts of your application can send messages to a channel's subscribers. As explained in Channel, most of the time, these
# broadcastings are streamed directly to the clients subscribed to the named broadcasting. Let's explain with a full-stack example:
#
#   class WebNotificationsChannel < ApplicationCable::Channel
#     def subscribed
#       stream_from "web_notifications_#{current_user.id}"
#     end
#   end
#
#   # Somewhere in your app this is called, perhaps from a NewCommentJob:
#   ActionCable.server.broadcast \
#     "web_notifications_1", { title: "New things!", body: "All that's fit for print" }
#
#   # Client-side CoffeeScript, which assumes you've already requested the right to send web notifications:
#   App.cable.subscriptions.create "WebNotificationsChannel",
#     received: (data) ->
#       new Notification data['title'], body: data['body']
#
# source://actioncable-5.2.8.1/lib/action_cable/server/broadcasting.rb:22
module ActionCable::Server::Broadcasting
  # Broadcast a hash directly to a named <tt>broadcasting</tt>. This will later be JSON encoded.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/broadcasting.rb:24
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  # Returns a broadcaster for a named <tt>broadcasting</tt> that can be reused. Useful when you have an object that
  # may need multiple spots to transmit to a specific broadcasting over and over.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/broadcasting.rb:30
  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

# source://actioncable-5.2.8.1/lib/action_cable/server/broadcasting.rb:35
class ActionCable::Server::Broadcasting::Broadcaster
  # @return [Broadcaster] a new instance of Broadcaster
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/broadcasting.rb:38
  def initialize(server, broadcasting, coder:); end

  # source://actioncable-5.2.8.1/lib/action_cable/server/broadcasting.rb:42
  def broadcast(message); end

  # Returns the value of attribute broadcasting.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/broadcasting.rb:36
  def broadcasting; end

  # Returns the value of attribute coder.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/broadcasting.rb:36
  def coder; end

  # Returns the value of attribute server.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/broadcasting.rb:36
  def server; end
end

# An instance of this configuration object is available via ActionCable.server.config, which allows you to tweak Action Cable configuration
# in a Rails config initializer.
#
# source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:7
class ActionCable::Server::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:13
  def initialize; end

  # Returns the value of attribute allow_same_origin_as_host.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:10
  def allow_same_origin_as_host; end

  # Sets the attribute allow_same_origin_as_host
  #
  # @param value the value to set the attribute allow_same_origin_as_host to.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:10
  def allow_same_origin_as_host=(_arg0); end

  # Returns the value of attribute allowed_request_origins.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:10
  def allowed_request_origins; end

  # Sets the attribute allowed_request_origins
  #
  # @param value the value to set the attribute allowed_request_origins to.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:10
  def allowed_request_origins=(_arg0); end

  # Returns the value of attribute cable.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:11
  def cable; end

  # Sets the attribute cable
  #
  # @param value the value to set the attribute cable to.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:11
  def cable=(_arg0); end

  # Returns the value of attribute connection_class.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:9
  def connection_class; end

  # Sets the attribute connection_class
  #
  # @param value the value to set the attribute connection_class to.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:9
  def connection_class=(_arg0); end

  # Returns the value of attribute disable_request_forgery_protection.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:10
  def disable_request_forgery_protection; end

  # Sets the attribute disable_request_forgery_protection
  #
  # @param value the value to set the attribute disable_request_forgery_protection to.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:10
  def disable_request_forgery_protection=(_arg0); end

  # Returns the value of attribute log_tags.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:8
  def log_tags; end

  # Sets the attribute log_tags
  #
  # @param value the value to set the attribute log_tags to.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:8
  def log_tags=(_arg0); end

  # Returns the value of attribute logger.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:8
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:8
  def logger=(_arg0); end

  # Returns the value of attribute mount_path.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:11
  def mount_path; end

  # Sets the attribute mount_path
  #
  # @param value the value to set the attribute mount_path to.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:11
  def mount_path=(_arg0); end

  # Returns constant of subscription adapter specified in config/cable.yml.
  # If the adapter cannot be found, this will default to the Redis adapter.
  # Also makes sure proper dependencies are required.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:26
  def pubsub_adapter; end

  # Returns the value of attribute url.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:11
  def url; end

  # Sets the attribute url
  #
  # @param value the value to set the attribute url to.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:11
  def url=(_arg0); end

  # Returns the value of attribute worker_pool_size.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:9
  def worker_pool_size; end

  # Sets the attribute worker_pool_size
  #
  # @param value the value to set the attribute worker_pool_size to.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/configuration.rb:9
  def worker_pool_size=(_arg0); end
end

# Collection class for all the connections that have been established on this specific server. Remember, usually you'll run many Action Cable servers, so
# you can't use this collection as a full list of all of the connections established against your application. Instead, use RemoteConnections for that.
#
# source://actioncable-5.2.8.1/lib/action_cable/server/connections.rb:7
module ActionCable::Server::Connections
  # source://actioncable-5.2.8.1/lib/action_cable/server/connections.rb:14
  def add_connection(connection); end

  # source://actioncable-5.2.8.1/lib/action_cable/server/connections.rb:10
  def connections; end

  # source://actioncable-5.2.8.1/lib/action_cable/server/connections.rb:31
  def open_connections_statistics; end

  # source://actioncable-5.2.8.1/lib/action_cable/server/connections.rb:18
  def remove_connection(connection); end

  # WebSocket connection implementations differ on when they'll mark a connection as stale. We basically never want a connection to go stale, as you
  # then can't rely on being able to communicate with the connection. To solve this, a 3 second heartbeat runs on all connections. If the beat fails, we automatically
  # disconnect.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/connections.rb:25
  def setup_heartbeat_timer; end
end

# source://actioncable-5.2.8.1/lib/action_cable/server/connections.rb:8
ActionCable::Server::Connections::BEAT_INTERVAL = T.let(T.unsafe(nil), Integer)

# Worker used by Server.send_async to do connection work in threads.
#
# source://actioncable-5.2.8.1/lib/action_cable/server/worker.rb:10
class ActionCable::Server::Worker
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # @return [Worker] a new instance of Worker
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/worker.rb:19
  def initialize(max_size: T.unsafe(nil)); end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:124
  def __callbacks; end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:132
  def __callbacks?; end

  # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:815
  def _run_work_callbacks(&block); end

  # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:827
  def _work_callbacks; end

  # source://actioncable-5.2.8.1/lib/action_cable/server/worker.rb:47
  def async_exec(receiver, *args, connection:, &block); end

  # source://actioncable-5.2.8.1/lib/action_cable/server/worker.rb:51
  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb:55
  def connection; end

  # source://activesupport-5.2.8.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb:97
  def connection=(obj); end

  # Returns the value of attribute executor.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/worker.rb:17
  def executor; end

  # Stop processing work: any work that has not already started
  # running will be discarded from the queue
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/worker.rb:29
  def halt; end

  # source://actioncable-5.2.8.1/lib/action_cable/server/worker.rb:57
  def invoke(receiver, method, *args, connection:, &block); end

  # @return [Boolean]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/server/worker.rb:33
  def stopping?; end

  # source://actioncable-5.2.8.1/lib/action_cable/server/worker.rb:37
  def work(connection); end

  private

  # source://actioncable-5.2.8.1/lib/action_cable/server/worker.rb:72
  def logger; end

  class << self
    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:106
    def __callbacks; end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:104
    def __callbacks=(val); end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/class/attribute.rb:99
    def __callbacks?; end

    # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:819
    def _work_callbacks; end

    # source://activesupport-5.2.8.1/lib/active_support/callbacks.rb:823
    def _work_callbacks=(value); end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb:48
    def connection; end

    # source://activesupport-5.2.8.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb:90
    def connection=(obj); end
  end
end

# source://actioncable-5.2.8.1/lib/action_cable/server/worker/active_record_connection_management.rb:6
module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Concern

  # source://actioncable-5.2.8.1/lib/action_cable/server/worker/active_record_connection_management.rb:15
  def with_database_connections; end
end

# source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter.rb:4
module ActionCable::SubscriptionAdapter
  extend ::ActiveSupport::Autoload
end

# source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/base.rb:5
class ActionCable::SubscriptionAdapter::Base
  # @return [Base] a new instance of Base
  #
  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/base.rb:8
  def initialize(server); end

  # @raise [NotImplementedError]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/base.rb:13
  def broadcast(channel, payload); end

  # Returns the value of attribute logger.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/base.rb:6
  def logger; end

  # Returns the value of attribute server.
  #
  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/base.rb:6
  def server; end

  # @raise [NotImplementedError]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/base.rb:25
  def shutdown; end

  # @raise [NotImplementedError]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/base.rb:17
  def subscribe(channel, message_callback, success_callback = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  #
  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/base.rb:21
  def unsubscribe(channel, message_callback); end
end

# source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/channel_prefix.rb:5
module ActionCable::SubscriptionAdapter::ChannelPrefix
  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/channel_prefix.rb:6
  def broadcast(channel, payload); end

  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/channel_prefix.rb:11
  def subscribe(channel, callback, success_callback = T.unsafe(nil)); end

  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/channel_prefix.rb:16
  def unsubscribe(channel, callback); end

  private

  # Returns the channel name, including channel_prefix specified in cable.yml
  #
  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/channel_prefix.rb:23
  def channel_with_prefix(channel); end
end

# source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/subscriber_map.rb:5
class ActionCable::SubscriptionAdapter::SubscriberMap
  # @return [SubscriberMap] a new instance of SubscriberMap
  #
  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/subscriber_map.rb:6
  def initialize; end

  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/subscriber_map.rb:47
  def add_channel(channel, on_success); end

  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/subscriber_map.rb:11
  def add_subscriber(channel, subscriber, on_success); end

  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/subscriber_map.rb:36
  def broadcast(channel, message); end

  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/subscriber_map.rb:54
  def invoke_callback(callback, message); end

  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/subscriber_map.rb:51
  def remove_channel(channel); end

  # source://actioncable-5.2.8.1/lib/action_cable/subscription_adapter/subscriber_map.rb:25
  def remove_subscriber(channel, subscriber); end
end

# source://actioncable-5.2.8.1/lib/action_cable/gem_version.rb:9
module ActionCable::VERSION; end

# source://actioncable-5.2.8.1/lib/action_cable/gem_version.rb:10
ActionCable::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://actioncable-5.2.8.1/lib/action_cable/gem_version.rb:11
ActionCable::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://actioncable-5.2.8.1/lib/action_cable/gem_version.rb:13
ActionCable::VERSION::PRE = T.let(T.unsafe(nil), String)

# source://actioncable-5.2.8.1/lib/action_cable/gem_version.rb:15
ActionCable::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://actioncable-5.2.8.1/lib/action_cable/gem_version.rb:12
ActionCable::VERSION::TINY = T.let(T.unsafe(nil), Integer)
