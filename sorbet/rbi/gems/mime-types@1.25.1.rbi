# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mime-types` gem.
# Please instead update this file by running `bin/tapioca gem mime-types`.

# The namespace for MIME applications, tools, and libraries.
#
# source://mime-types-1.25.1/lib/mime/types.rb:4
module MIME; end

# Reflects a MIME Content-Type which is in invalid format (e.g., it isn't
# in the form of type/subtype).
#
# source://mime-types-1.25.1/lib/mime/types.rb:7
class MIME::InvalidContentType < ::RuntimeError; end

# The definition of one MIME content-type.
#
# == Usage
#  require 'mime/types'
#
#  plaintext = MIME::Types['text/plain'].first
#  # returns [text/plain, text/plain]
#  text      = plaintext.first
#  print text.media_type           # => 'text'
#  print text.sub_type             # => 'plain'
#
#  puts text.extensions.join(" ")  # => 'asc txt c cc h hh cpp'
#
#  puts text.encoding              # => 8bit
#  puts text.binary?               # => false
#  puts text.ascii?                # => true
#  puts text == 'text/plain'       # => true
#  puts MIME::Type.simplified('x-appl/x-zip') # => 'appl/zip'
#
#  puts MIME::Types.any? { |type|
#    type.content_type == 'text/plain'
#  }                               # => true
#  puts MIME::Types.all?(&:registered?)
#                                  # => false
#
# source://mime-types-1.25.1/lib/mime/types.rb:34
class MIME::Type
  include ::Comparable

  # Builds a MIME::Type object from the provided MIME Content Type value
  # (e.g., 'text/plain' or 'applicaton/x-eruby'). The constructed object
  # is yielded to an optional block for additional configuration, such as
  # associating extensions and encoding information.
  #
  # @return [Type] a new instance of Type
  # @yield [_self]
  # @yieldparam _self [MIME::Type] the object that the method was called on
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:413
  def initialize(content_type); end

  # Compares the MIME::Type against the exact content type or the
  # simplified type (the simplified type will be used if comparing against
  # something that can be treated as a String with #to_s). In comparisons,
  # this is done against the lowercase version of the MIME::Type.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:69
  def <=>(other); end

  # MIME types can be specified to be sent across a network in particular
  # formats. This method returns +false+ when the MIME type encoding is
  # set to <tt>base64</tt>.
  #
  # @return [Boolean]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:464
  def ascii?; end

  # MIME types can be specified to be sent across a network in particular
  # formats. This method returns +true+ when the MIME type encoding is set
  # to <tt>base64</tt>.
  #
  # @return [Boolean]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:457
  def binary?; end

  # Returns +true+ if the MIME::Type specifies an extension list,
  # indicating that it is a complete MIME::Type.
  #
  # @return [Boolean]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:487
  def complete?; end

  # Returns the whole MIME content-type string.
  #
  #   text/plain        => text/plain
  #   x-chemical/x-pdb  => x-chemical/x-pdb
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:131
  def content_type; end

  # Returns the default encoding for the MIME::Type based on the media
  # type.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:207
  def default_encoding; end

  # The documentation for this MIME::Type. Documentation about media
  # types will be found on a media type definition as a comment.
  # Documentation will be found through #docs.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:231
  def docs; end

  # The documentation for this MIME::Type. Documentation about media
  # types will be found on a media type definition as a comment.
  # Documentation will be found through #docs.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:233
  def docs=(d); end

  # The encoding (7bit, 8bit, quoted-printable, or base64) required to
  # transport the data of this content type safely across a network, which
  # roughly corresponds to Content-Transfer-Encoding. A value of +nil+ or
  # <tt>:default</tt> will reset the #encoding to the #default_encoding
  # for the MIME::Type. Raises ArgumentError if the encoding provided is
  # invalid.
  #
  # If the encoding is not provided on construction, this will be either
  # 'quoted-printable' (for text/* media types) and 'base64' for eveything
  # else.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:180
  def encoding; end

  # source://mime-types-1.25.1/lib/mime/types.rb:182
  def encoding=(enc); end

  # Returns +true+ if the other object is a MIME::Type and the content
  # types match.
  #
  # @return [Boolean]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:123
  def eql?(other); end

  # The list of extensions which are known to be used for this MIME::Type.
  # Non-array values will be coerced into an array with #to_a. Array
  # values will be flattened and +nil+ values removed.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:164
  def extensions; end

  # source://mime-types-1.25.1/lib/mime/types.rb:166
  def extensions=(ext); end

  # Returns +true+ if the simplified type matches the current
  #
  # @return [Boolean]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:57
  def like?(other); end

  # Returns the media type of the simplified MIME type.
  #
  #   text/plain        => text
  #   x-chemical/x-pdb  => chemical
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:136
  def media_type; end

  # Sets the obsolescence indicator for this media type.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:226
  def obsolete=(_arg0); end

  # Returns +true+ if the media type is obsolete.
  #
  # @return [Boolean]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:222
  def obsolete?; end

  # Returns +true+ if the MIME::Type is specific to the current operating
  # system as represented by RUBY_PLATFORM.
  #
  # @return [Boolean]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:481
  def platform?; end

  # Compares the MIME::Type based on how reliable it is before doing a
  # normal <=> comparison. Used by MIME::Types#[] to sort types. The
  # comparisons involved are:
  #
  # 1. self.simplified <=> other.simplified (ensures that we
  #    don't try to compare different types)
  # 2. IANA-registered definitions < other definitions.
  # 3. Generic definitions < platform definitions.
  # 3. Complete definitions < incomplete definitions.
  # 4. Current definitions < obsolete definitions.
  # 5. Obselete with use-instead references < obsolete without.
  # 6. Obsolete use-instead definitions are compared.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:91
  def priority_compare(other); end

  # Returns the media type of the unmodified MIME type.
  #
  #   text/plain        => text
  #   x-chemical/x-pdb  => x-chemical
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:141
  def raw_media_type; end

  # Returns the media type of the unmodified MIME type.
  #
  #   text/plain        => plain
  #   x-chemical/x-pdb  => x-pdb
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:151
  def raw_sub_type; end

  # source://mime-types-1.25.1/lib/mime/types.rb:452
  def registered=(_arg0); end

  # MIME content-types which are not regestered by IANA nor defined in
  # RFCs are required to start with <tt>x-</tt>. This counts as well for
  # a new media type as well as a new sub-type of an existing media
  # type. If either the media-type or the content-type begins with
  # <tt>x-</tt>, this method will return +false+.
  #
  # @return [Boolean]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:445
  def registered?; end

  # Returns +true+ when the simplified MIME type is in the list of known
  # digital signatures.
  #
  # @return [Boolean]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:470
  def signature?; end

  # The MIME types main- and sub-label can both start with <tt>x-</tt>,
  # which indicates that it is a non-registered name. Of course, after
  # registration this flag can disappear, adds to the confusing
  # proliferation of MIME types. The simplified string has the <tt>x-</tt>
  # removed and are translated to lowercase.
  #
  #   text/plain        => text/plain
  #   x-chemical/x-pdb  => chemical/pdb
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:160
  def simplified; end

  # Returns the sub-type of the simplified MIME type.
  #
  #   text/plain        => plain
  #   x-chemical/x-pdb  => pdb
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:146
  def sub_type; end

  # The regexp for the operating system that this MIME::Type is specific
  # to.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:194
  def system; end

  # source://mime-types-1.25.1/lib/mime/types.rb:196
  def system=(os); end

  # Returns +true+ if the MIME::Type is specific to an operating system.
  #
  # @return [Boolean]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:475
  def system?; end

  # Returns the MIME type as an array suitable for use with
  # MIME::Type.from_array.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:503
  def to_a; end

  # Returns the MIME type as an array suitable for use with
  # MIME::Type.from_hash.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:510
  def to_hash; end

  # Returns the MIME type as a string.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:492
  def to_s; end

  # Returns the MIME type as a string for implicit conversions.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:497
  def to_str; end

  # The encoded URL list for this MIME::Type. See #urls for more
  # information.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:248
  def url; end

  # The encoded URL list for this MIME::Type. See #urls for more
  # information.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:248
  def url=(_arg0); end

  # The decoded URL list for this MIME::Type.
  # The special URL value IANA will be translated into:
  #   http://www.iana.org/assignments/media-types/<mediatype>/<subtype>
  #
  # The special URL value RFC### will be translated into:
  #   http://www.rfc-editor.org/rfc/rfc###.txt
  #
  # The special URL value DRAFT:name will be translated into:
  #   https://datatracker.ietf.org/public/idindex.cgi?
  #       command=id_detail&filename=<name>
  #
  # The special URL value LTSW will be translated into:
  #   http://www.ltsw.se/knbase/internet/<mediatype>.htp
  #
  # The special URL value [token] will be translated into:
  #   http://www.iana.org/assignments/contact-people.htm#<token>
  #
  # These values will be accessible through #urls, which always returns an
  # array.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:268
  def urls; end

  # Returns the media type or types that should be used instead of this
  # media type, if it is obsolete. If there is no replacement media type,
  # or it is not obsolete, +nil+ will be returned.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:216
  def use_instead; end

  class << self
    # Creates a MIME::Type from an array in the form of:
    #   [type-name, [extensions], encoding, system]
    #
    # +extensions+, +encoding+, and +system+ are optional.
    #
    #   MIME::Type.from_array("application/x-ruby", ['rb'], '8bit')
    #   MIME::Type.from_array(["application/x-ruby", ['rb'], '8bit'])
    #
    # These are equivalent to:
    #
    #   MIME::Type.new('application/x-ruby') do |t|
    #     t.extensions  = %w(rb)
    #     t.encoding    = '8bit'
    #   end
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:324
    def from_array(*args); end

    # Creates a MIME::Type from a hash. Keys are case-insensitive,
    # dashes may be replaced with underscores, and the internal Symbol
    # of the lowercase-underscore version can be used as well. That is,
    # Content-Type can be provided as content-type, Content_Type,
    # content_type, or :content_type.
    #
    # Known keys are <tt>Content-Type</tt>,
    # <tt>Content-Transfer-Encoding</tt>, <tt>Extensions</tt>, and
    # <tt>System</tt>.
    #
    #   MIME::Type.from_hash('Content-Type' => 'text/x-yaml',
    #                        'Content-Transfer-Encoding' => '8bit',
    #                        'System' => 'linux',
    #                        'Extensions' => ['yaml', 'yml'])
    #
    # This is equivalent to:
    #
    #   MIME::Type.new('text/x-yaml') do |t|
    #     t.encoding    = '8bit'
    #     t.system      = 'linux'
    #     t.extensions  = ['yaml', 'yml']
    #   end
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:361
    def from_hash(hash); end

    # Essentially a copy constructor.
    #
    #   MIME::Type.from_mime_type(plaintext)
    #
    # is equivalent to:
    #
    #   MIME::Type.new(plaintext.content_type.dup) do |t|
    #     t.extensions  = plaintext.extensions.dup
    #     t.system      = plaintext.system.dup
    #     t.encoding    = plaintext.encoding.dup
    #   end
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:391
    def from_mime_type(mime_type); end

    # The MIME types main- and sub-label can both start with <tt>x-</tt>,
    # which indicates that it is a non-registered name. Of course, after
    # registration this flag can disappear, adds to the confusing
    # proliferation of MIME types. The simplified string has the
    # <tt>x-</tt> removed and are translated to lowercase.
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:297
    def simplified(content_type); end
  end
end

# source://mime-types-1.25.1/lib/mime/types.rb:54
MIME::Type::CONTACT_URL = T.let(T.unsafe(nil), String)

# source://mime-types-1.25.1/lib/mime/types.rb:52
MIME::Type::DRAFT_URL = T.let(T.unsafe(nil), String)

# source://mime-types-1.25.1/lib/mime/types.rb:42
MIME::Type::ENCODING_RE = T.let(T.unsafe(nil), Regexp)

# source://mime-types-1.25.1/lib/mime/types.rb:50
MIME::Type::IANA_URL = T.let(T.unsafe(nil), String)

# source://mime-types-1.25.1/lib/mime/types.rb:53
MIME::Type::LTSW_URL = T.let(T.unsafe(nil), String)

# source://mime-types-1.25.1/lib/mime/types.rb:40
MIME::Type::MEDIA_TYPE_RE = T.let(T.unsafe(nil), Regexp)

# source://mime-types-1.25.1/lib/mime/types.rb:43
MIME::Type::PLATFORM_RE = T.let(T.unsafe(nil), Regexp)

# source://mime-types-1.25.1/lib/mime/types.rb:51
MIME::Type::RFC_URL = T.let(T.unsafe(nil), String)

# source://mime-types-1.25.1/lib/mime/types.rb:45
MIME::Type::SIGNATURES = T.let(T.unsafe(nil), Array)

# source://mime-types-1.25.1/lib/mime/types.rb:41
MIME::Type::UNREG_RE = T.let(T.unsafe(nil), Regexp)

# The released version of Ruby MIME::Types
#
# source://mime-types-1.25.1/lib/mime/types.rb:36
MIME::Type::VERSION = T.let(T.unsafe(nil), String)

# = MIME::Types
# MIME types are used in MIME-compliant communications, as in e-mail or
# HTTP traffic, to indicate the type of content which is transmitted.
# MIME::Types provides the ability for detailed information about MIME
# entities (provided as a set of MIME::Type objects) to be determined and
# used programmatically. There are many types defined by RFCs and vendors,
# so the list is long but not complete; don't hesitate to ask to add
# additional information. This library follows the IANA collection of MIME
# types (see below for reference).
#
# == Description
# MIME types are used in MIME entities, as in email or HTTP traffic. It is
# useful at times to have information available about MIME types (or,
# inversely, about files). A MIME::Type stores the known information about
# one MIME type.
#
# == Usage
#  require 'mime/types'
#
#  plaintext = MIME::Types['text/plain']
#  print plaintext.media_type           # => 'text'
#  print plaintext.sub_type             # => 'plain'
#
#  puts plaintext.extensions.join(" ")  # => 'asc txt c cc h hh cpp'
#
#  puts plaintext.encoding              # => 8bit
#  puts plaintext.binary?               # => false
#  puts plaintext.ascii?                # => true
#  puts plaintext.obsolete?             # => false
#  puts plaintext.registered?           # => true
#  puts plaintext == 'text/plain'       # => true
#  puts MIME::Type.simplified('x-appl/x-zip') # => 'appl/zip'
#
# This module is built to conform to the MIME types of RFCs 2045 and 2231.
# It follows the official IANA registry at
# http://www.iana.org/assignments/media-types/ and
# ftp://ftp.iana.org/assignments/media-types with some unofficial types
# added from the the collection at
# http://www.ltsw.se/knbase/internet/mime.htp
#
# source://mime-types-1.25.1/lib/mime/types.rb:562
class MIME::Types
  extend ::Enumerable

  # @return [Types] a new instance of Types
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:591
  def initialize(data_version = T.unsafe(nil)); end

  # Returns a list of MIME::Type objects, which may be empty. The optional
  # flag parameters are :complete (finds only complete MIME::Type objects)
  # and :platform (finds only MIME::Types for the current platform). It is
  # possible for multiple matches to be returned for either type (in the
  # example below, 'text/plain' returns two values -- one for the general
  # case, and one for VMS systems.
  #
  #   puts "\nMIME::Types['text/plain']"
  #   MIME::Types['text/plain'].each { |t| puts t.to_a.join(", ") }
  #
  #   puts "\nMIME::Types[/^image/, :complete => true]"
  #   MIME::Types[/^image/, :complete => true].each do |t|
  #     puts t.to_a.join(", ")
  #   end
  #
  # If multiple type definitions are returned, returns them sorted as
  # follows:
  #   1. Complete definitions sort before incomplete ones;
  #   2. IANA-registered definitions sort before LTSW-recorded
  #      definitions.
  #   3. Generic definitions sort before platform-specific ones;
  #   4. Current definitions sort before obsolete ones;
  #   5. Obsolete definitions with use-instead clauses sort before those
  #      without;
  #   6. Obsolete definitions use-instead clauses are compared.
  #   7. Sort on name.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:648
  def [](type_id, flags = T.unsafe(nil)); end

  # Add one or more MIME::Type objects to the set of known types. Each
  # type should be experimental (e.g., 'application/x-ruby'). If the type
  # is already known, a warning will be displayed.
  #
  # <strong>Please inform the maintainer of this module when registered
  # types are missing.</strong>
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:689
  def add(*types); end

  # source://mime-types-1.25.1/lib/mime/types.rb:597
  def add_type_variant(mime_type); end

  # Returns the number of known types. A shortcut of MIME::Types[//].size.
  # (Keep in mind that this is memory intensive, cache the result to spare
  # resources)
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:612
  def count; end

  # The data version.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:568
  def data_version; end

  # source://mime-types-1.25.1/lib/mime/types.rb:605
  def defined_types; end

  # source://mime-types-1.25.1/lib/mime/types.rb:616
  def each; end

  # source://mime-types-1.25.1/lib/mime/types.rb:601
  def index_extensions(mime_type); end

  # A synonym for MIME::Types.type_for
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:679
  def of(filename, platform = T.unsafe(nil)); end

  # Return the list of MIME::Types which belongs to the file based on its
  # filename extension. If +platform+ is +true+, then only file types that
  # are specific to the current platform will be returned.
  #
  # This will always return an array.
  #
  #   puts "MIME::Types.type_for('citydesk.xml')
  #     => [application/xml, text/xml]
  #   puts "MIME::Types.type_for('citydesk.gif')
  #     => [image/gif]
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:671
  def type_for(filename, platform = T.unsafe(nil)); end

  private

  # source://mime-types-1.25.1/lib/mime/types.rb:712
  def match(pattern); end

  # source://mime-types-1.25.1/lib/mime/types.rb:706
  def prune_matches(matches, flags); end

  class << self
    # Returns a list of MIME::Type objects, which may be empty. The
    # optional flag parameters are :complete (finds only complete
    # MIME::Type objects) and :platform (finds only MIME::Types for the
    # current platform). It is possible for multiple matches to be
    # returned for either type (in the example below, 'text/plain' returns
    # two values -- one for the general case, and one for VMS systems.
    #
    #   puts "\nMIME::Types['text/plain']"
    #   MIME::Types['text/plain'].each { |t| puts t.to_a.join(", ") }
    #
    #   puts "\nMIME::Types[/^image/, :complete => true]"
    #   MIME::Types[/^image/, :complete => true].each do |t|
    #     puts t.to_a.join(", ")
    #   end
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:849
    def [](type_id, flags = T.unsafe(nil)); end

    # Add one or more MIME::Type objects to the set of known types. Each
    # type should be experimental (e.g., 'application/x-ruby'). If the
    # type is already known, a warning will be displayed.
    #
    # <strong>Please inform the maintainer of this module when registered
    # types are missing.</strong>
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:888
    def add(*types); end

    # source://mime-types-1.25.1/lib/mime/types.rb:722
    def add_type_variant(mime_type); end

    # Returns the currently defined cache file, if any.
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:893
    def cache_file; end

    # source://mime-types-1.25.1/lib/mime/types.rb:855
    def count; end

    # source://mime-types-1.25.1/lib/mime/types.rb:859
    def each; end

    # source://mime-types-1.25.1/lib/mime/types.rb:726
    def index_extensions(mime_type); end

    # Build the type list from a file in the format:
    #
    #   [*][!][os:]mt/st[<ws>@ext][<ws>:enc][<ws>'url-list][<ws>=docs]
    #
    # == *
    # An unofficial MIME type. This should be used if and only if the MIME type
    # is not properly specified (that is, not under either x-type or
    # vnd.name.type).
    #
    # == !
    # An obsolete MIME type. May be used with an unofficial MIME type.
    #
    # == os:
    # Platform-specific MIME type definition.
    #
    # == mt
    # The media type.
    #
    # == st
    # The media subtype.
    #
    # == <ws>@ext
    # The list of comma-separated extensions.
    #
    # == <ws>:enc
    # The encoding.
    #
    # == <ws>'url-list
    # The list of comma-separated URLs.
    #
    # == <ws>=docs
    # The documentation string.
    #
    # That is, everything except the media type and the subtype is optional. The
    # more information that's available, though, the richer the values that can
    # be provided.
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:784
    def load_from_file(filename); end

    # A synonym for MIME::Types.type_for
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:878
    def of(filename, platform = T.unsafe(nil)); end

    # Return the list of MIME::Types which belongs to the file based on
    # its filename extension. If +platform+ is +true+, then only file
    # types that are specific to the current platform will be returned.
    #
    # This will always return an array.
    #
    #   puts "MIME::Types.type_for('citydesk.xml')
    #     => [application/xml, text/xml]
    #   puts "MIME::Types.type_for('citydesk.gif')
    #     => [image/gif]
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:873
    def type_for(filename, platform = T.unsafe(nil)); end

    private

    # source://mime-types-1.25.1/lib/mime/types.rb:950
    def __types__; end

    # @return [Boolean]
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:946
    def lazy_load?; end

    # source://mime-types-1.25.1/lib/mime/types.rb:938
    def load_and_parse_mime_types; end

    # source://mime-types-1.25.1/lib/mime/types.rb:955
    def load_mime_types; end

    # source://mime-types-1.25.1/lib/mime/types.rb:898
    def load_mime_types_from_cache; end

    # @raise [ArgumentError]
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:902
    def load_mime_types_from_cache!; end

    # source://mime-types-1.25.1/lib/mime/types.rb:922
    def write_mime_types_to_cache; end

    # @raise [ArgumentError]
    #
    # source://mime-types-1.25.1/lib/mime/types.rb:926
    def write_mime_types_to_cache!; end
  end
end

# source://mime-types-1.25.1/lib/mime/types.rb:584
class MIME::Types::CacheContainer
  # @return [CacheContainer] a new instance of CacheContainer
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:586
  def initialize(version, data); end

  # Returns the value of attribute data.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:585
  def data; end

  # Returns the value of attribute version.
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:585
  def version; end
end

# source://mime-types-1.25.1/lib/mime/types.rb:565
MIME::Types::DATA_VERSION = T.let(T.unsafe(nil), Integer)

# source://mime-types-1.25.1/lib/mime/types.rb:570
class MIME::Types::HashWithArrayDefault < ::Hash
  # @return [HashWithArrayDefault] a new instance of HashWithArrayDefault
  #
  # source://mime-types-1.25.1/lib/mime/types.rb:571
  def initialize; end

  # source://mime-types-1.25.1/lib/mime/types.rb:575
  def marshal_dump; end

  # source://mime-types-1.25.1/lib/mime/types.rb:579
  def marshal_load(hash); end
end

# The released version of Ruby MIME::Types
#
# source://mime-types-1.25.1/lib/mime/types.rb:564
MIME::Types::VERSION = T.let(T.unsafe(nil), String)
