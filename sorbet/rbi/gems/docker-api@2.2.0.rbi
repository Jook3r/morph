# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `docker-api` gem.
# Please instead update this file by running `bin/tapioca gem docker-api`.

# The top-level module for this gem. Its purpose is to hold global
# configuration variables that are used as defaults in other classes.
#
# source://docker-api-2.2.0/lib/docker.rb:21
module Docker
  private

  # Login to the Docker registry.
  #
  # source://docker-api-2.2.0/lib/docker.rb:133
  def authenticate!(options = T.unsafe(nil), connection = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker.rb:93
  def connection; end

  # Returns the value of attribute creds.
  #
  # source://docker-api-2.2.0/lib/docker.rb:22
  def creds; end

  # Sets the attribute creds
  #
  # @param value the value to set the attribute creds to.
  #
  # source://docker-api-2.2.0/lib/docker.rb:22
  def creds=(_arg0); end

  # source://docker-api-2.2.0/lib/docker.rb:39
  def default_socket_url; end

  # source://docker-api-2.2.0/lib/docker.rb:47
  def env_options; end

  # source://docker-api-2.2.0/lib/docker.rb:43
  def env_url; end

  # Get more information about the Docker server.
  #
  # source://docker-api-2.2.0/lib/docker.rb:113
  def info(connection = T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://docker-api-2.2.0/lib/docker.rb:22
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://docker-api-2.2.0/lib/docker.rb:22
  def logger=(_arg0); end

  # source://docker-api-2.2.0/lib/docker.rb:79
  def options; end

  # source://docker-api-2.2.0/lib/docker.rb:88
  def options=(new_options); end

  # Ping the Docker server.
  #
  # source://docker-api-2.2.0/lib/docker.rb:118
  def ping(connection = T.unsafe(nil)); end

  # Determine if the server is podman or docker.
  #
  # @return [Boolean]
  #
  # source://docker-api-2.2.0/lib/docker.rb:123
  def podman?(connection = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker.rb:97
  def reset!; end

  # source://docker-api-2.2.0/lib/docker.rb:103
  def reset_connection!; end

  # Determine if the session is rootless.
  #
  # @return [Boolean]
  #
  # source://docker-api-2.2.0/lib/docker.rb:128
  def rootless?(connection = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker.rb:60
  def ssl_options; end

  # source://docker-api-2.2.0/lib/docker.rb:70
  def url; end

  # source://docker-api-2.2.0/lib/docker.rb:83
  def url=(new_url); end

  # Get the version of Go, Docker, and optionally the Git commit.
  #
  # source://docker-api-2.2.0/lib/docker.rb:108
  def version(connection = T.unsafe(nil)); end

  class << self
    # Login to the Docker registry.
    #
    # source://docker-api-2.2.0/lib/docker.rb:133
    def authenticate!(options = T.unsafe(nil), connection = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker.rb:93
    def connection; end

    # Returns the value of attribute creds.
    #
    # source://docker-api-2.2.0/lib/docker.rb:22
    def creds; end

    # Sets the attribute creds
    #
    # @param value the value to set the attribute creds to.
    #
    # source://docker-api-2.2.0/lib/docker.rb:22
    def creds=(_arg0); end

    # source://docker-api-2.2.0/lib/docker.rb:39
    def default_socket_url; end

    # source://docker-api-2.2.0/lib/docker.rb:47
    def env_options; end

    # source://docker-api-2.2.0/lib/docker.rb:43
    def env_url; end

    # Get more information about the Docker server.
    #
    # source://docker-api-2.2.0/lib/docker.rb:113
    def info(connection = T.unsafe(nil)); end

    # Returns the value of attribute logger.
    #
    # source://docker-api-2.2.0/lib/docker.rb:22
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    #
    # source://docker-api-2.2.0/lib/docker.rb:22
    def logger=(_arg0); end

    # source://docker-api-2.2.0/lib/docker.rb:79
    def options; end

    # source://docker-api-2.2.0/lib/docker.rb:88
    def options=(new_options); end

    # Ping the Docker server.
    #
    # source://docker-api-2.2.0/lib/docker.rb:118
    def ping(connection = T.unsafe(nil)); end

    # Determine if the server is podman or docker.
    #
    # @return [Boolean]
    #
    # source://docker-api-2.2.0/lib/docker.rb:123
    def podman?(connection = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker.rb:97
    def reset!; end

    # source://docker-api-2.2.0/lib/docker.rb:103
    def reset_connection!; end

    # Determine if the session is rootless.
    #
    # @return [Boolean]
    #
    # source://docker-api-2.2.0/lib/docker.rb:128
    def rootless?(connection = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker.rb:60
    def ssl_options; end

    # source://docker-api-2.2.0/lib/docker.rb:70
    def url; end

    # source://docker-api-2.2.0/lib/docker.rb:83
    def url=(new_url); end

    # Get the version of Go, Docker, and optionally the Git commit.
    #
    # source://docker-api-2.2.0/lib/docker.rb:108
    def version(connection = T.unsafe(nil)); end
  end
end

# This class is a base class for Docker Container and Image.
# It is implementing accessor methods for the models attributes.
#
# source://docker-api-2.2.0/lib/docker/base.rb:3
module Docker::Base
  include ::Docker::Error

  # The private new method accepts a connection and a hash of options that must include an id.
  #
  # @raise [ArgumentError]
  #
  # source://docker-api-2.2.0/lib/docker/base.rb:10
  def initialize(connection, hash = T.unsafe(nil)); end

  # Returns the value of attribute connection.
  #
  # source://docker-api-2.2.0/lib/docker/base.rb:6
  def connection; end

  # Sets the attribute connection
  #
  # @param value the value to set the attribute connection to.
  #
  # source://docker-api-2.2.0/lib/docker/base.rb:6
  def connection=(_arg0); end

  # Returns the value of attribute id.
  #
  # source://docker-api-2.2.0/lib/docker/base.rb:7
  def id; end

  # Returns the value of attribute info.
  #
  # source://docker-api-2.2.0/lib/docker/base.rb:6
  def info; end

  # Sets the attribute info
  #
  # @param value the value to set the attribute info to.
  #
  # source://docker-api-2.2.0/lib/docker/base.rb:6
  def info=(_arg0); end

  # The docker-api will some time return "ID" other times it will return "Id"
  # and other times it will return "id". This method normalize it to "id"
  # The volumes endpoint returns Name instead of ID, added in the normalize function
  #
  # source://docker-api-2.2.0/lib/docker/base.rb:22
  def normalize_hash(hash); end
end

# This class represents a Connection to a Docker server. The Connection is
# immutable in that once the url and options is set they cannot be changed.
#
# source://docker-api-2.2.0/lib/docker/connection.rb:3
class Docker::Connection
  include ::Docker::Error

  # Create a new Connection. This method takes a url (String) and options
  # (Hash). These are passed to Excon, so any options valid for `Excon.new`
  # can be passed here.
  #
  # @return [Connection] a new instance of Connection
  #
  # source://docker-api-2.2.0/lib/docker/connection.rb:14
  def initialize(url, opts); end

  # source://docker-api-2.2.0/lib/docker/connection.rb:109
  def delete(*args, &block); end

  # source://docker-api-2.2.0/lib/docker/connection.rb:109
  def get(*args, &block); end

  # Common attribute requests
  #
  # source://docker-api-2.2.0/lib/docker/connection.rb:113
  def info; end

  # source://docker-api-2.2.0/lib/docker/connection.rb:95
  def log_request(request); end

  # Returns the value of attribute options.
  #
  # source://docker-api-2.2.0/lib/docker/connection.rb:9
  def options; end

  # source://docker-api-2.2.0/lib/docker/connection.rb:117
  def ping; end

  # @return [Boolean]
  #
  # source://docker-api-2.2.0/lib/docker/connection.rb:121
  def podman?; end

  # source://docker-api-2.2.0/lib/docker/connection.rb:109
  def post(*args, &block); end

  # source://docker-api-2.2.0/lib/docker/connection.rb:109
  def put(*args, &block); end

  # Send a request to the server with the `
  #
  # source://docker-api-2.2.0/lib/docker/connection.rb:40
  def request(*args, &block); end

  # @return [Boolean]
  #
  # source://docker-api-2.2.0/lib/docker/connection.rb:129
  def rootless?; end

  # source://docker-api-2.2.0/lib/docker/connection.rb:103
  def to_s; end

  # Returns the value of attribute url.
  #
  # source://docker-api-2.2.0/lib/docker/connection.rb:9
  def url; end

  # source://docker-api-2.2.0/lib/docker/connection.rb:133
  def version; end

  private

  # Given an HTTP method, path, optional query, extra options, and block,
  # compiles a request.
  #
  # source://docker-api-2.2.0/lib/docker/connection.rb:140
  def compile_request_params(http_method, path, query = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # The actual client that sends HTTP methods to the Docker server. This value
  # is not cached, since doing so may cause socket errors after bad requests.
  #
  # source://docker-api-2.2.0/lib/docker/connection.rb:34
  def resource; end
end

# This class represents a Docker Container. It's important to note that nothing
# is cached so that the information is always up to date.
#
# source://docker-api-2.2.0/lib/docker/container.rb:3
class Docker::Container
  include ::Docker::Error
  include ::Docker::Base

  # source://docker-api-2.2.0/lib/docker/container.rb:278
  def archive_in(inputs, output_path, opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/container.rb:286
  def archive_in_stream(output_path, opts = T.unsafe(nil), &block); end

  # source://docker-api-2.2.0/lib/docker/container.rb:269
  def archive_out(path, &block); end

  # Attach to a container's standard streams / logs.
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:103
  def attach(options = T.unsafe(nil), excon_params = T.unsafe(nil), &block); end

  # source://docker-api-2.2.0/lib/docker/container.rb:153
  def changes(opts = T.unsafe(nil)); end

  # Create an Image from a Container's change.s
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:132
  def commit(options = T.unsafe(nil)); end

  # remove container
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:248
  def delete(options = T.unsafe(nil)); end

  # Create an Exec instance inside the container
  #
  # @param command [String, Array] The command to run inside the Exec instance
  # @param options [Hash] The options to pass to Docker::Exec
  # @return [Docker::Exec] The Exec instance
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:55
  def exec(command, options = T.unsafe(nil), &block); end

  # Export the Container as a tar.
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:97
  def export(&block); end

  # source://docker-api-2.2.0/lib/docker/container.rb:153
  def json(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/container.rb:215
  def kill(*args); end

  # source://docker-api-2.2.0/lib/docker/container.rb:206
  def kill!(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/container.rb:158
  def logs(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/container.rb:264
  def pause; end

  # source://docker-api-2.2.0/lib/docker/container.rb:259
  def pause!; end

  # source://docker-api-2.2.0/lib/docker/container.rb:300
  def read_file(path); end

  # Update the @info hash, which is the only mutable state in this object.
  #   e.g. if you would like a live status from the #info hash, call #refresh! first.
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:8
  def refresh!; end

  # remove container
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:248
  def remove(options = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/container.rb:181
  def rename(new_name); end

  # source://docker-api-2.2.0/lib/docker/container.rb:242
  def restart(*args); end

  # source://docker-api-2.2.0/lib/docker/container.rb:224
  def restart!(opts = T.unsafe(nil)); end

  # Given a command and an optional number of seconds to wait for the currently
  # executing command, creates a new Container to run the specified command. If
  # the command that is currently executing does not return a 0 status code, an
  # UnexpectedResponseError is raised.
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:41
  def run(cmd, time = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/container.rb:215
  def start(*args); end

  # source://docker-api-2.2.0/lib/docker/container.rb:201
  def start!(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/container.rb:162
  def stats(options = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/container.rb:242
  def stop(*args); end

  # source://docker-api-2.2.0/lib/docker/container.rb:224
  def stop!(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/container.rb:315
  def store_file(path, file_content); end

  # source://docker-api-2.2.0/lib/docker/container.rb:191
  def streaming_logs(opts = T.unsafe(nil), &block); end

  # Return a String representation of the Container.
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:146
  def to_s; end

  # Return a List of Hashes that represents the top running processes.
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:19
  def top(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/container.rb:264
  def unpause; end

  # source://docker-api-2.2.0/lib/docker/container.rb:259
  def unpause!; end

  # source://docker-api-2.2.0/lib/docker/container.rb:187
  def update(opts); end

  # Wait for the current command to finish executing. Default wait time is
  # `Excon.options[:read_timeout]`.
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:31
  def wait(time = T.unsafe(nil)); end

  private

  # Convenience method to return the path for a particular resource.
  #
  # source://docker-api-2.2.0/lib/docker/container.rb:354
  def path_for(resource); end

  class << self
    # Return all of the Containers.
    #
    # source://docker-api-2.2.0/lib/docker/container.rb:342
    def all(opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # Create a new Container.
    #
    # source://docker-api-2.2.0/lib/docker/container.rb:326
    def create(opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # Return the container with specified ID
    #
    # source://docker-api-2.2.0/lib/docker/container.rb:335
    def get(id, opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # Prune images
    #
    # source://docker-api-2.2.0/lib/docker/container.rb:348
    def prune(conn = T.unsafe(nil)); end
  end
end

# This module holds the Errors for the gem.
#
# source://docker-api-2.2.0/lib/docker/error.rb:2
module Docker::Error; end

# Raised when invalid arguments are passed to a method.
#
# source://docker-api-2.2.0/lib/docker/error.rb:9
class Docker::Error::ArgumentError < ::Docker::Error::DockerError; end

# Raised when login fails.
#
# source://docker-api-2.2.0/lib/docker/error.rb:36
class Docker::Error::AuthenticationError < ::Docker::Error::DockerError; end

# Raised when a request returns a 400.
#
# source://docker-api-2.2.0/lib/docker/error.rb:12
class Docker::Error::ClientError < ::Docker::Error::DockerError; end

# Raised when a request returns a 409.
#
# source://docker-api-2.2.0/lib/docker/error.rb:21
class Docker::Error::ConflictError < ::Docker::Error::DockerError; end

# The default error. It's never actually raised, but can be used to catch all
# gem-specific errors that are thrown as they all subclass from this.
#
# source://docker-api-2.2.0/lib/docker/error.rb:6
class Docker::Error::DockerError < ::StandardError; end

# Raised when an IO action fails.
#
# source://docker-api-2.2.0/lib/docker/error.rb:39
class Docker::Error::IOError < ::Docker::Error::DockerError; end

# Raised when a request returns a 404.
#
# source://docker-api-2.2.0/lib/docker/error.rb:18
class Docker::Error::NotFoundError < ::Docker::Error::DockerError; end

# Raised when a request returns a 500.
#
# source://docker-api-2.2.0/lib/docker/error.rb:24
class Docker::Error::ServerError < ::Docker::Error::DockerError; end

# Raised when a request times out.
#
# source://docker-api-2.2.0/lib/docker/error.rb:33
class Docker::Error::TimeoutError < ::Docker::Error::DockerError; end

# Raised when a request returns a 401.
#
# source://docker-api-2.2.0/lib/docker/error.rb:15
class Docker::Error::UnauthorizedError < ::Docker::Error::DockerError; end

# Raised when there is an unexpected response code / body.
#
# source://docker-api-2.2.0/lib/docker/error.rb:27
class Docker::Error::UnexpectedResponseError < ::Docker::Error::DockerError; end

# Raised when there is an incompatible version of Docker.
#
# source://docker-api-2.2.0/lib/docker/error.rb:30
class Docker::Error::VersionError < ::Docker::Error::DockerError; end

# This class represents a Docker Event.
#
# source://docker-api-2.2.0/lib/docker/event.rb:2
class Docker::Event
  include ::Docker::Error
  extend ::Docker::Error

  # @return [Event] a new instance of Event
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:54
  def initialize(event_attributes = T.unsafe(nil)); end

  # Returns the value of attribute Action.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def Action; end

  # Sets the attribute Action
  #
  # @param value the value to set the attribute Action to.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def Action=(_arg0); end

  # Returns the value of attribute Actor.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:50
  def Actor; end

  # source://docker-api-2.2.0/lib/docker/event.rb:76
  def Actor=(actor); end

  # source://docker-api-2.2.0/lib/docker/event.rb:72
  def ID; end

  # Returns the value of attribute Type.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def Type; end

  # Sets the attribute Type
  #
  # @param value the value to set the attribute Type to.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def Type=(_arg0); end

  # Returns the value of attribute Action.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def action; end

  # Returns the value of attribute Actor.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:50
  def actor; end

  # Deprecated interface
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:52
  def from; end

  # Deprecated interface
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:52
  def from=(_arg0); end

  # source://docker-api-2.2.0/lib/docker/event.rb:72
  def id; end

  # Deprecated interface
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:52
  def status; end

  # Deprecated interface
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:52
  def status=(_arg0); end

  # Returns the value of attribute time.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def time; end

  # Sets the attribute time
  #
  # @param value the value to set the attribute time to.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def time=(_arg0); end

  # Returns the value of attribute timeNano.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def timeNano; end

  # Sets the attribute timeNano
  #
  # @param value the value to set the attribute timeNano to.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def timeNano=(_arg0); end

  # Returns the value of attribute timeNano.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def time_nano; end

  # source://docker-api-2.2.0/lib/docker/event.rb:91
  def to_s; end

  # Returns the value of attribute Type.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:49
  def type; end

  private

  # source://docker-api-2.2.0/lib/docker/event.rb:112
  def to_s_actor_style; end

  # source://docker-api-2.2.0/lib/docker/event.rb:101
  def to_s_legacy; end

  class << self
    # source://docker-api-2.2.0/lib/docker/event.rb:42
    def new_event(body, remaining, total); end

    # source://docker-api-2.2.0/lib/docker/event.rb:38
    def since(since, opts = T.unsafe(nil), conn = T.unsafe(nil), &block); end

    # source://docker-api-2.2.0/lib/docker/event.rb:30
    def stream(opts = T.unsafe(nil), conn = T.unsafe(nil), &block); end
  end
end

# Represents the actor object nested within an event
#
# source://docker-api-2.2.0/lib/docker/event.rb:6
class Docker::Event::Actor
  # @return [Actor] a new instance of Actor
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:9
  def initialize(actor_attributes = T.unsafe(nil)); end

  # Returns the value of attribute Attributes.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:7
  def Attributes; end

  # Sets the attribute Attributes
  #
  # @param value the value to set the attribute Attributes to.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:7
  def Attributes=(_arg0); end

  # Returns the value of attribute ID.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:7
  def ID; end

  # Sets the attribute ID
  #
  # @param value the value to set the attribute ID to.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:7
  def ID=(_arg0); end

  # Returns the value of attribute Attributes.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:7
  def attributes; end

  # Returns the value of attribute ID.
  #
  # source://docker-api-2.2.0/lib/docker/event.rb:7
  def id; end
end

# This class represents a Docker Exec Instance.
#
# source://docker-api-2.2.0/lib/docker/exec.rb:2
class Docker::Exec
  include ::Docker::Error
  include ::Docker::Base

  # Get info about the Exec instance
  #
  # source://docker-api-2.2.0/lib/docker/exec.rb:37
  def json; end

  # Resize the TTY associated with the Exec instance
  #
  # @option query
  # @option query
  # @param query [Hash] API query parameters
  # @return [Docker::Exec] self
  #
  # source://docker-api-2.2.0/lib/docker/exec.rb:99
  def resize(query = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/exec.rb:87
  def start(*args); end

  # Start the Exec instance. The Exec instance is deleted after this so this
  # command can only be run once.
  #
  # @option options
  # @option options
  # @option options
  # @param options [Hash] Options to dictate behavior of the instance
  # @return [Array, Array, Int] The STDOUT, STDERR and exit code
  #
  # source://docker-api-2.2.0/lib/docker/exec.rb:52
  def start!(options = T.unsafe(nil), &block); end

  # Convert details about the object into a string
  #
  # @return [String] String representation of the Exec instance object
  #
  # source://docker-api-2.2.0/lib/docker/exec.rb:8
  def to_s; end

  private

  # Get the request URI for the given endpoint
  #
  # @param endpoint [Symbol] The endpoint to grab
  # @return [String] The full Remote API endpoint with ID
  #
  # source://docker-api-2.2.0/lib/docker/exec.rb:108
  def path_for(endpoint); end

  class << self
    # Create a new Exec instance in a running container. Please note, this does
    # NOT execute the instance - you must run #start. Also, each instance is
    # one-time use only.
    #
    # @param options [Hash] Parameters to pass in to the API.
    # @param conn [Docker::Connection] Connection to Docker Remote API
    # @return [Docker::Exec] self
    #
    # source://docker-api-2.2.0/lib/docker/exec.rb:20
    def create(options = T.unsafe(nil), conn = T.unsafe(nil)); end
  end
end

# This class represents a Docker Image.
#
# source://docker-api-2.2.0/lib/docker/image.rb:2
class Docker::Image
  include ::Docker::Error
  include ::Docker::Base

  # Remove the Image from the server.
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:67
  def delete(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/image.rb:91
  def history(opts = T.unsafe(nil)); end

  # Given a path of a local file and the path it should be inserted, creates
  # a new Image that has that file.
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:51
  def insert_local(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/image.rb:91
  def json(opts = T.unsafe(nil)); end

  # Push the Image to the Docker registry.
  #
  # @raise [ArgumentError]
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:25
  def push(creds = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Update the @info hash, which is the only mutable state in this object.
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:107
  def refresh!; end

  # Remove the Image from the server.
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:67
  def remove(opts = T.unsafe(nil)); end

  # Given a command and optional list of streams to attach to, run a command on
  # an Image. This will not modify the Image, but rather create a new Container
  # to run the Image. If the image has an embedded config, no command is
  # necessary, but it will fail with 500 if no config is saved with the image
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:9
  def run(cmd = T.unsafe(nil), options = T.unsafe(nil)); end

  # Save the image as a tarball
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:97
  def save(filename = T.unsafe(nil)); end

  # Save the image as a tarball to an IO object.
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:102
  def save_stream(opts = T.unsafe(nil), &block); end

  # Tag the Image.
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:41
  def tag(opts = T.unsafe(nil)); end

  # Return a String representation of the Image.
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:83
  def to_s; end

  private

  # Convience method to get the Dockerfile for a file hash and a path to
  # output to.
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:342
  def dockerfile_for(file_hash, output_path); end

  # source://docker-api-2.2.0/lib/docker/image.rb:352
  def ensure_repo_tags; end

  # Convenience method to return the path for a particular resource.
  #
  # source://docker-api-2.2.0/lib/docker/image.rb:335
  def path_for(resource); end

  class << self
    # Return every Image.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:217
    def all(opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # Given a Dockerfile as a string, builds an Image.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:269
    def build(commands, opts = T.unsafe(nil), connection = T.unsafe(nil), &block); end

    # Given a directory that contains a Dockerfile, builds an Image.
    #
    # If a block is passed, chunks of output produced by Docker will be passed
    # to that block.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:307
    def build_from_dir(dir, opts = T.unsafe(nil), connection = T.unsafe(nil), creds = T.unsafe(nil), &block); end

    # Given File like object containing a tar file, builds an Image.
    #
    # If a block is passed, chunks of output produced by Docker will be passed
    # to that block.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:285
    def build_from_tar(tar, opts = T.unsafe(nil), connection = T.unsafe(nil), creds = T.unsafe(nil), &block); end

    # A method to build the config header and merge it into the
    # headers sent by build_from_dir.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:324
    def build_headers(creds = T.unsafe(nil)); end

    # Create a new Image.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:119
    def create(opts = T.unsafe(nil), creds = T.unsafe(nil), conn = T.unsafe(nil), &block); end

    # Delete a specific image
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:144
    def delete(id, opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # Check if an image exists.
    #
    # @return [Boolean]
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:209
    def exist?(id, opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # Return a specific image.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:137
    def get(id, opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # Import an Image from the output of Docker::Container#export. The first
    # argument may either be a File or URI.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:238
    def import(imp, opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker/image.rb:257
    def import_stream(options = T.unsafe(nil), connection = T.unsafe(nil), &block); end

    # Load a tar Image
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:196
    def load(tar, opts = T.unsafe(nil), conn = T.unsafe(nil), creds = T.unsafe(nil), &block); end

    # Prune images
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:150
    def prune(conn = T.unsafe(nil)); end

    # Delete a specific image
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:144
    def remove(id, opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # Generates the block to be passed as a reponse block to Excon. The returned
    # lambda will append Docker output to the first argument, and yield output to
    # the passed block, if a block is given.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:360
    def response_block(body); end

    # Generates the block to be passed in to the save request. This lambda will
    # append the streaming data to the file provided.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:369
    def response_block_for_save(file); end

    # Save the raw binary representation or one or more Docker images
    #
    # representation of the binary data. If the filename is not nil, then
    # return nil.
    #
    # @param names [String, Array#String] The image(s) you wish to save
    # @param filename [String] The file to export the data to.
    # @param conn [Docker::Connection] The Docker connection to use
    # @return [NilClass, String] If filename is nil, return the string
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:164
    def save(names, filename = T.unsafe(nil), conn = T.unsafe(nil)); end

    # Stream the contents of Docker image(s) to a block.
    #
    # @param names [String, Array#String] The image(s) you wish to save
    # @param conn [Docker::Connection] The Docker connection to use
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:182
    def save_stream(names, opts = T.unsafe(nil), conn = T.unsafe(nil), &block); end

    # Given a query like `{ :term => 'sshd' }`, queries the Docker Registry for
    # a corresponding Image.
    #
    # source://docker-api-2.2.0/lib/docker/image.rb:224
    def search(query = T.unsafe(nil), connection = T.unsafe(nil), creds = T.unsafe(nil)); end
  end
end

# This class represents all the messages either received by chunks from attach
#
# source://docker-api-2.2.0/lib/docker/messages.rb:2
class Docker::Messages
  # @return [Messages] a new instance of Messages
  #
  # source://docker-api-2.2.0/lib/docker/messages.rb:6
  def initialize(stdout_messages = T.unsafe(nil), stderr_messages = T.unsafe(nil), all_messages = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/messages.rb:16
  def add_message(source, message); end

  # Returns the value of attribute all_messages.
  #
  # source://docker-api-2.2.0/lib/docker/messages.rb:4
  def all_messages; end

  # Sets the attribute all_messages
  #
  # @param value the value to set the attribute all_messages to.
  #
  # source://docker-api-2.2.0/lib/docker/messages.rb:4
  def all_messages=(_arg0); end

  # source://docker-api-2.2.0/lib/docker/messages.rb:42
  def append(messages); end

  # Returns the value of attribute buffer.
  #
  # source://docker-api-2.2.0/lib/docker/messages.rb:4
  def buffer; end

  # Sets the attribute buffer
  #
  # @param value the value to set the attribute buffer to.
  #
  # source://docker-api-2.2.0/lib/docker/messages.rb:4
  def buffer=(_arg0); end

  # source://docker-api-2.2.0/lib/docker/messages.rb:51
  def clear; end

  # Method to break apart application/vnd.docker.raw-stream headers
  #
  # source://docker-api-2.2.0/lib/docker/messages.rb:58
  def decipher_messages(body); end

  # source://docker-api-2.2.0/lib/docker/messages.rb:26
  def get_message(raw_text); end

  # Returns the value of attribute stderr_messages.
  #
  # source://docker-api-2.2.0/lib/docker/messages.rb:4
  def stderr_messages; end

  # Sets the attribute stderr_messages
  #
  # @param value the value to set the attribute stderr_messages to.
  #
  # source://docker-api-2.2.0/lib/docker/messages.rb:4
  def stderr_messages=(_arg0); end

  # Returns the value of attribute stdout_messages.
  #
  # source://docker-api-2.2.0/lib/docker/messages.rb:4
  def stdout_messages; end

  # Sets the attribute stdout_messages
  #
  # @param value the value to set the attribute stdout_messages to.
  #
  # source://docker-api-2.2.0/lib/docker/messages.rb:4
  def stdout_messages=(_arg0); end
end

# This class represents a messages stack
#
# source://docker-api-2.2.0/lib/docker/messages_stack.rb:2
class Docker::MessagesStack
  # Initialize stack with optional size
  #
  # @param size [Integer]
  # @return [MessagesStack] a new instance of MessagesStack
  #
  # source://docker-api-2.2.0/lib/docker/messages_stack.rb:9
  def initialize(size = T.unsafe(nil)); end

  # Append messages to stack
  #
  # @param messages [Docker::Messages]
  #
  # source://docker-api-2.2.0/lib/docker/messages_stack.rb:17
  def append(messages); end

  # Returns the value of attribute messages.
  #
  # source://docker-api-2.2.0/lib/docker/messages_stack.rb:4
  def messages; end

  # Sets the attribute messages
  #
  # @param value the value to set the attribute messages to.
  #
  # source://docker-api-2.2.0/lib/docker/messages_stack.rb:4
  def messages=(_arg0); end
end

# This class represents a Docker Network.
#
# source://docker-api-2.2.0/lib/docker/network.rb:2
class Docker::Network
  include ::Docker::Error
  include ::Docker::Base

  # source://docker-api-2.2.0/lib/docker/network.rb:5
  def connect(container, opts = T.unsafe(nil), body_opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/network.rb:21
  def delete(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/network.rb:13
  def disconnect(container, opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/network.rb:27
  def json(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/network.rb:36
  def reload; end

  # source://docker-api-2.2.0/lib/docker/network.rb:21
  def remove(opts = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/network.rb:31
  def to_s; end

  private

  # Convenience method to return the path for a particular resource.
  #
  # source://docker-api-2.2.0/lib/docker/network.rb:77
  def path_for(resource = T.unsafe(nil)); end

  class << self
    # source://docker-api-2.2.0/lib/docker/network.rb:59
    def all(opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker/network.rb:43
    def create(name, opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker/network.rb:64
    def delete(id, opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker/network.rb:53
    def get(id, opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker/network.rb:70
    def prune(conn = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker/network.rb:64
    def remove(id, opts = T.unsafe(nil), conn = T.unsafe(nil)); end
  end
end

# This module holds shared logic that doesn't really belong anywhere else in the
# gem.
#
# source://docker-api-2.2.0/lib/docker/util.rb:5
module Docker::Util
  include ::Docker::Error

  private

  # source://docker-api-2.2.0/lib/docker/util.rb:191
  def add_file_to_tar(tar, name, mode, size, mtime); end

  # Attaches to a HTTP stream
  #
  # @param block
  # @param msg_stack [Docker::Messages]
  # @param tty [boolean]
  #
  # source://docker-api-2.2.0/lib/docker/util.rb:18
  def attach_for(block, msg_stack, tty = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/util.rb:38
  def attach_for_multiplex(block, msg_stack); end

  # source://docker-api-2.2.0/lib/docker/util.rb:27
  def attach_for_tty(block, msg_stack); end

  # source://docker-api-2.2.0/lib/docker/util.rb:261
  def build_auth_header(credentials); end

  # source://docker-api-2.2.0/lib/docker/util.rb:269
  def build_config_header(credentials); end

  # source://docker-api-2.2.0/lib/docker/util.rb:96
  def close_write(socket); end

  # source://docker-api-2.2.0/lib/docker/util.rb:138
  def create_dir_tar(directory); end

  # source://docker-api-2.2.0/lib/docker/util.rb:173
  def create_relative_dir_tar(directory, output); end

  # source://docker-api-2.2.0/lib/docker/util.rb:124
  def create_tar(hash = T.unsafe(nil)); end

  # source://docker-api-2.2.0/lib/docker/util.rb:216
  def create_temp_file; end

  # source://docker-api-2.2.0/lib/docker/util.rb:56
  def debug(msg); end

  # return the set of files that form the docker context
  # implement this logic https://docs.docker.com/engine/reference/builder/#dockerignore-file
  #
  # source://docker-api-2.2.0/lib/docker/util.rb:150
  def docker_context(directory); end

  # do a directory glob that matches .dockerignore behavior
  # specifically: matched directories are considered a recursive match
  #
  # source://docker-api-2.2.0/lib/docker/util.rb:291
  def dockerignore_compatible_glob(pattern); end

  # source://docker-api-2.2.0/lib/docker/util.rb:221
  def extract_id(body); end

  # Convenience method to get the file hash corresponding to an array of
  # local paths.
  #
  # source://docker-api-2.2.0/lib/docker/util.rb:232
  def file_hash_from_paths(local_paths); end

  # source://docker-api-2.2.0/lib/docker/util.rb:256
  def filesystem_permissions(path); end

  # source://docker-api-2.2.0/lib/docker/util.rb:120
  def fix_json(body); end

  # source://docker-api-2.2.0/lib/docker/util.rb:303
  def glob_all_files(pattern); end

  # source://docker-api-2.2.0/lib/docker/util.rb:60
  def hijack_for(stdin, block, msg_stack, tty); end

  # source://docker-api-2.2.0/lib/docker/util.rb:106
  def parse_json(body); end

  # source://docker-api-2.2.0/lib/docker/util.rb:112
  def parse_repo_tag(str); end

  class << self
    # @yield [os]
    #
    # source://docker-api-2.2.0/lib/docker/util.rb:191
    def add_file_to_tar(tar, name, mode, size, mtime); end

    # Attaches to a HTTP stream
    #
    # @param block
    # @param msg_stack [Docker::Messages]
    # @param tty [boolean]
    #
    # source://docker-api-2.2.0/lib/docker/util.rb:18
    def attach_for(block, msg_stack, tty = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker/util.rb:38
    def attach_for_multiplex(block, msg_stack); end

    # source://docker-api-2.2.0/lib/docker/util.rb:27
    def attach_for_tty(block, msg_stack); end

    # source://docker-api-2.2.0/lib/docker/util.rb:261
    def build_auth_header(credentials); end

    # source://docker-api-2.2.0/lib/docker/util.rb:269
    def build_config_header(credentials); end

    # source://docker-api-2.2.0/lib/docker/util.rb:96
    def close_write(socket); end

    # source://docker-api-2.2.0/lib/docker/util.rb:138
    def create_dir_tar(directory); end

    # source://docker-api-2.2.0/lib/docker/util.rb:173
    def create_relative_dir_tar(directory, output); end

    # source://docker-api-2.2.0/lib/docker/util.rb:124
    def create_tar(hash = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker/util.rb:216
    def create_temp_file; end

    # source://docker-api-2.2.0/lib/docker/util.rb:56
    def debug(msg); end

    # return the set of files that form the docker context
    # implement this logic https://docs.docker.com/engine/reference/builder/#dockerignore-file
    #
    # source://docker-api-2.2.0/lib/docker/util.rb:150
    def docker_context(directory); end

    # do a directory glob that matches .dockerignore behavior
    # specifically: matched directories are considered a recursive match
    #
    # source://docker-api-2.2.0/lib/docker/util.rb:291
    def dockerignore_compatible_glob(pattern); end

    # @raise [UnexpectedResponseError]
    #
    # source://docker-api-2.2.0/lib/docker/util.rb:221
    def extract_id(body); end

    # Convenience method to get the file hash corresponding to an array of
    # local paths.
    #
    # source://docker-api-2.2.0/lib/docker/util.rb:232
    def file_hash_from_paths(local_paths); end

    # source://docker-api-2.2.0/lib/docker/util.rb:256
    def filesystem_permissions(path); end

    # source://docker-api-2.2.0/lib/docker/util.rb:120
    def fix_json(body); end

    # source://docker-api-2.2.0/lib/docker/util.rb:303
    def glob_all_files(pattern); end

    # source://docker-api-2.2.0/lib/docker/util.rb:60
    def hijack_for(stdin, block, msg_stack, tty); end

    # source://docker-api-2.2.0/lib/docker/util.rb:106
    def parse_json(body); end

    # source://docker-api-2.2.0/lib/docker/util.rb:112
    def parse_repo_tag(str); end
  end
end

# http://www.tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm#STANDARD-WILDCARDS
#
# source://docker-api-2.2.0/lib/docker/util.rb:7
Docker::Util::GLOB_WILDCARDS = T.let(T.unsafe(nil), Regexp)

# The version of the docker-api gem.
#
# source://docker-api-2.2.0/lib/docker/version.rb:3
Docker::VERSION = T.let(T.unsafe(nil), String)

# class represents a Docker Volume
#
# source://docker-api-2.2.0/lib/docker/volume.rb:2
class Docker::Volume
  include ::Docker::Error
  include ::Docker::Base

  # source://docker-api-2.2.0/lib/docker/volume.rb:10
  def normalize_hash(hash); end

  # /volumes/volume_name doesnt return anything
  #
  # source://docker-api-2.2.0/lib/docker/volume.rb:6
  def remove(opts = T.unsafe(nil), conn = T.unsafe(nil)); end

  class << self
    # /volumes endpoint returns an array of hashes incapsulated in an Volumes tag
    #
    # source://docker-api-2.2.0/lib/docker/volume.rb:24
    def all(opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # creates a volume with an arbitrary name
    #
    # source://docker-api-2.2.0/lib/docker/volume.rb:32
    def create(name, opts = T.unsafe(nil), conn = T.unsafe(nil)); end

    # get details for a single volume
    #
    # source://docker-api-2.2.0/lib/docker/volume.rb:17
    def get(name, conn = T.unsafe(nil)); end

    # source://docker-api-2.2.0/lib/docker/volume.rb:39
    def prune(conn = T.unsafe(nil)); end
  end
end

# source://docker-api-2.2.0/lib/excon/middlewares/hijack.rb:1
module Excon
  class << self
    # source://excon-0.92.4/lib/excon.rb:249
    def connect(url, params = T.unsafe(nil), &block); end

    # source://excon-0.92.4/lib/excon.rb:49
    def defaults; end

    # source://excon-0.92.4/lib/excon.rb:55
    def defaults=(new_defaults); end

    # source://excon-0.92.4/lib/excon.rb:249
    def delete(url, params = T.unsafe(nil), &block); end

    # source://excon-0.92.4/lib/excon.rb:59
    def display_warning(warning); end

    # source://excon-0.92.4/lib/excon.rb:249
    def get(url, params = T.unsafe(nil), &block); end

    # source://excon-0.92.4/lib/excon.rb:249
    def head(url, params = T.unsafe(nil), &block); end

    # source://excon-0.92.4/lib/excon.rb:75
    def mock; end

    # source://excon-0.92.4/lib/excon.rb:83
    def mock=(new_mock); end

    # source://excon-0.92.4/lib/excon.rb:119
    def new(url, params = T.unsafe(nil)); end

    # source://excon-0.92.4/lib/excon.rb:249
    def options(url, params = T.unsafe(nil), &block); end

    # source://excon-0.92.4/lib/excon.rb:249
    def patch(url, params = T.unsafe(nil), &block); end

    # source://excon-0.92.4/lib/excon.rb:249
    def post(url, params = T.unsafe(nil), &block); end

    # source://excon-0.92.4/lib/excon.rb:249
    def put(url, params = T.unsafe(nil), &block); end

    # source://excon-0.92.4/lib/excon.rb:70
    def set_raise_on_warnings!(should_raise); end

    # source://excon-0.92.4/lib/excon.rb:89
    def ssl_ca_path; end

    # source://excon-0.92.4/lib/excon.rb:96
    def ssl_ca_path=(new_ssl_ca_path); end

    # source://excon-0.92.4/lib/excon.rb:102
    def ssl_verify_peer; end

    # source://excon-0.92.4/lib/excon.rb:109
    def ssl_verify_peer=(new_ssl_verify_peer); end

    # source://excon-0.92.4/lib/excon.rb:148
    def stub(request_params = T.unsafe(nil), response_params = T.unsafe(nil), &block); end

    # source://excon-0.92.4/lib/excon.rb:192
    def stub_for(request_params = T.unsafe(nil)); end

    # source://excon-0.92.4/lib/excon.rb:229
    def stubs; end

    # source://excon-0.92.4/lib/excon.rb:249
    def trace(url, params = T.unsafe(nil), &block); end

    # source://excon-0.92.4/lib/excon.rb:241
    def unstub(request_params = T.unsafe(nil)); end
  end
end

# source://excon-0.92.4/lib/excon/constants.rb:12
Excon::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://excon-0.92.4/lib/excon/constants.rb:4
Excon::CR_NL = T.let(T.unsafe(nil), String)

# source://excon-0.92.4/lib/excon/constants.rb:134
Excon::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://excon-0.92.4/lib/excon/constants.rb:6
Excon::DEFAULT_CA_FILE = T.let(T.unsafe(nil), String)

# source://excon-0.92.4/lib/excon/constants.rb:8
Excon::DEFAULT_CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://excon-0.92.4/lib/excon/constants.rb:15
Excon::DEFAULT_REDIRECT_LIMIT = T.let(T.unsafe(nil), Integer)

# source://excon-0.92.4/lib/excon/constants.rb:19
Excon::DEFAULT_RETRY_ERRORS = T.let(T.unsafe(nil), Array)

# source://excon-0.92.4/lib/excon/constants.rb:17
Excon::DEFAULT_RETRY_LIMIT = T.let(T.unsafe(nil), Integer)

# source://excon-0.92.4/lib/excon/constants.rb:110
Excon::DEPRECATED_VALID_REQUEST_KEYS = T.let(T.unsafe(nil), Hash)

# source://excon-0.92.4/lib/excon/constants.rb:25
Excon::FORCE_ENC = T.let(T.unsafe(nil), TrueClass)

# source://excon-0.92.4/lib/excon/constants.rb:31
Excon::HTTPS = T.let(T.unsafe(nil), String)

# source://excon-0.92.4/lib/excon/constants.rb:27
Excon::HTTP_1_1 = T.let(T.unsafe(nil), String)

# source://excon-0.92.4/lib/excon/constants.rb:29
Excon::HTTP_VERBS = T.let(T.unsafe(nil), Array)

# source://docker-api-2.2.0/lib/excon/middlewares/hijack.rb:4
module Excon::Middleware; end

# Hijack is an Excon middleware which parses response headers and then
# yields the underlying TCP socket for raw TCP communication (used to
# attach to STDIN of containers).
#
# source://docker-api-2.2.0/lib/excon/middlewares/hijack.rb:8
class Excon::Middleware::Hijack < ::Excon::Middleware::Base
  # source://docker-api-2.2.0/lib/excon/middlewares/hijack.rb:9
  def build_response(status, socket); end

  # source://docker-api-2.2.0/lib/excon/middlewares/hijack.rb:28
  def response_call(datum); end
end

# source://excon-0.92.4/lib/excon/constants.rb:33
Excon::NO_ENTITY = T.let(T.unsafe(nil), Array)

# source://excon-0.92.4/lib/excon/constants.rb:35
Excon::REDACTED = T.let(T.unsafe(nil), String)

# source://excon-0.92.4/lib/excon/constants.rb:37
Excon::UNIX = T.let(T.unsafe(nil), String)

# source://excon-0.92.4/lib/excon/constants.rb:39
Excon::USER_AGENT = T.let(T.unsafe(nil), String)

# source://excon-0.92.4/lib/excon/constants.rb:68
Excon::VALID_CONNECTION_KEYS = T.let(T.unsafe(nil), Array)

# source://excon-0.92.4/lib/excon/constants.rb:43
Excon::VALID_REQUEST_KEYS = T.let(T.unsafe(nil), Array)

# source://excon-0.92.4/lib/excon/version.rb:3
Excon::VERSION = T.let(T.unsafe(nil), String)

# source://excon-0.92.4/lib/excon/constants.rb:41
Excon::VERSIONS = T.let(T.unsafe(nil), String)
