# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `webmock` gem.
# Please instead update this file by running `bin/tapioca gem webmock`.

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:33
module EventMachine
  private

  def add_oneshot_timer(_arg0); end
  def attach_fd(_arg0, _arg1); end
  def attach_sd(_arg0); end
  def bind_connect_server(_arg0, _arg1, _arg2, _arg3); end
  def close_connection(_arg0, _arg1); end
  def connect_server(_arg0, _arg1); end
  def connect_unix_server(_arg0); end
  def connection_paused?(_arg0); end
  def current_time; end
  def detach_fd(_arg0); end
  def epoll; end
  def epoll=(_arg0); end
  def epoll?; end
  def get_cipher_bits(_arg0); end
  def get_cipher_name(_arg0); end
  def get_cipher_protocol(_arg0); end
  def get_comm_inactivity_timeout(_arg0); end
  def get_connection_count; end
  def get_file_descriptor(_arg0); end
  def get_heartbeat_interval; end
  def get_idle_time(_arg0); end
  def get_max_timer_count; end
  def get_peer_cert(_arg0); end
  def get_peername(_arg0); end
  def get_pending_connect_timeout(_arg0); end
  def get_proxied_bytes(_arg0); end
  def get_simultaneous_accept_count; end
  def get_sni_hostname(_arg0); end
  def get_sock_opt(_arg0, _arg1, _arg2); end
  def get_sockname(_arg0); end
  def get_subprocess_pid(_arg0); end
  def get_subprocess_status(_arg0); end
  def initialize_event_machine; end
  def invoke_popen(_arg0); end
  def is_notify_readable(_arg0); end
  def is_notify_writable(_arg0); end
  def kqueue; end
  def kqueue=(_arg0); end
  def kqueue?; end
  def library_type; end
  def num_close_scheduled; end
  def open_udp_socket(_arg0, _arg1); end
  def pause_connection(_arg0); end
  def read_keyboard; end
  def release_machine; end
  def report_connection_error_status(_arg0); end
  def resume_connection(_arg0); end
  def run_machine; end
  def run_machine_once; end
  def run_machine_without_threads; end
  def send_data(_arg0, _arg1, _arg2); end
  def send_datagram(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def send_file_data(_arg0, _arg1); end
  def set_comm_inactivity_timeout(_arg0, _arg1); end
  def set_heartbeat_interval(_arg0); end
  def set_max_timer_count(_arg0); end
  def set_notify_readable(_arg0, _arg1); end
  def set_notify_writable(_arg0, _arg1); end
  def set_pending_connect_timeout(_arg0, _arg1); end
  def set_rlimit_nofile(_arg0); end
  def set_simultaneous_accept_count(_arg0); end
  def set_sock_opt(_arg0, _arg1, _arg2, _arg3); end
  def set_timer_quantum(_arg0); end
  def set_tls_parms(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9); end
  def setuid_string(_arg0); end
  def signal_loopbreak; end
  def ssl?; end
  def start_proxy(_arg0, _arg1, _arg2, _arg3); end
  def start_tcp_server(_arg0, _arg1); end
  def start_tls(_arg0); end
  def start_unix_server(_arg0); end
  def stop; end
  def stop_proxy(_arg0); end
  def stop_tcp_server(_arg0); end
  def stopping?; end
  def unwatch_filename(_arg0); end
  def unwatch_pid(_arg0); end
  def watch_filename(_arg0); end
  def watch_pid(_arg0); end

  class << self
    # Utility method for coercing arguments to an object that responds to :call.
    # Accepts an object and a method name to send to, or a block, or an object
    # that responds to :call.
    #
    # @example EventMachine.Callback used with a block. Returns that block.
    #
    #   cb = EventMachine.Callback do |msg|
    #   puts(msg)
    #   end
    #   # returned object is a callable
    #   cb.call('hello world')
    # @example EventMachine.Callback used with an object (to be more specific, class object) and a method name, returns an object that responds to #call
    #
    #   cb = EventMachine.Callback(Object, :puts)
    #   # returned object is a callable that delegates to Kernel#puts (in this case Object.puts)
    #   cb.call('hello world')
    # @example EventMachine.Callback used with an object that responds to #call. Returns the argument.
    #
    #   cb = EventMachine.Callback(proc{ |msg| puts(msg) })
    #   # returned object is a callable
    #   cb.call('hello world')
    # @overload Callback
    # @overload Callback
    # @overload Callback
    # @raise [ArgumentError] When argument doesn't respond to #call, method name is missing or when invoked without arguments and block isn't given
    # @return [<#call>]
    #
    # source://eventmachine-1.2.7/lib/em/callback.rb:47
    def Callback(object = T.unsafe(nil), method = T.unsafe(nil), &blk); end

    # @private
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1563
    def _open_file_for_writing(filename, handler = T.unsafe(nil)); end

    # Changed 04Oct06: intervals from the caller are now in milliseconds, but our native-ruby
    # processor still wants them in seconds.
    #
    # @private
    def add_oneshot_timer(_arg0); end

    # Adds a periodic timer to the event loop.
    # It takes the same parameters as the one-shot timer method, {EventMachine.add_timer}.
    # This method schedules execution of the given block repeatedly, at intervals
    # of time *at least* as great as the number of seconds given in the first
    # parameter to the call.
    #
    # @example Write a dollar-sign to stderr every five seconds, without blocking
    #
    #   EventMachine.run {
    #   EventMachine.add_periodic_timer( 5 ) { $stderr.write "$" }
    #   }
    # @param delay [Integer] Delay in seconds
    # @see EventMachine::PeriodicTimer
    # @see EventMachine.add_timer
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:351
    def add_periodic_timer(*args, &block); end

    # Adds a block to call as the reactor is shutting down.
    #
    # These callbacks are called in the _reverse_ order to which they are added.
    #
    # @example Scheduling operations to be run when EventMachine event loop is stopped
    #
    #   EventMachine.run do
    #   EventMachine.add_shutdown_hook { puts "b" }
    #   EventMachine.add_shutdown_hook { puts "a" }
    #   EventMachine.stop
    #   end
    #
    #   # Outputs:
    #   #   a
    #   #   b
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:291
    def add_shutdown_hook(&block); end

    # Adds a one-shot timer to the event loop.
    # Call it with one or two parameters. The first parameters is a delay-time
    # expressed in *seconds* (not milliseconds). The second parameter, if
    # present, must be an object that responds to :call. If 2nd parameter is not given, then you
    # can also simply pass a block to the method call.
    #
    # This method may be called from the block passed to {EventMachine.run}
    # or from any callback method. It schedules execution of the proc or block
    # passed to it, after the passage of an interval of time equal to
    # *at least* the number of seconds specified in the first parameter to
    # the call.
    #
    # {EventMachine.add_timer} is a non-blocking method. Callbacks can and will
    # be called during the interval of time that the timer is in effect.
    # There is no built-in limit to the number of timers that can be outstanding at
    # any given time.
    #
    # @example Setting a one-shot timer with EventMachine
    #
    #   EventMachine.run {
    #   puts "Starting the run now: #{Time.now}"
    #   EventMachine.add_timer 5, proc { puts "Executing timer event: #{Time.now}" }
    #   EventMachine.add_timer(10) { puts "Executing timer event: #{Time.now}" }
    #   }
    # @param delay [Integer] Delay in seconds
    # @see EventMachine::Timer
    # @see EventMachine.add_periodic_timer
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:323
    def add_timer(*args, &block); end

    # Attaches an IO object or file descriptor to the eventloop as a regular connection.
    # The file descriptor will be set as non-blocking, and EventMachine will process
    # receive_data and send_data events on it as it would for any other connection.
    #
    # To watch a fd instead, use {EventMachine.watch}, which will not alter the state of the socket
    # and fire notify_readable and notify_writable events instead.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:741
    def attach(io, handler = T.unsafe(nil), *args, &blk); end

    # @private
    def attach_fd(_arg0, _arg1); end

    # @private
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:746
    def attach_io(io, watch_mode, handler = T.unsafe(nil), *args); end

    def attach_sd(_arg0); end

    # Attach to an existing socket's file descriptor. The socket may have been
    # started with {EventMachine.start_server}.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:541
    def attach_server(sock, handler = T.unsafe(nil), *args, &block); end

    # This method is like {EventMachine.connect}, but allows for a local address/port
    # to bind the connection to.
    #
    # @see EventMachine.connect
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:661
    def bind_connect(bind_addr, bind_port, server, port = T.unsafe(nil), handler = T.unsafe(nil), *args); end

    # @private
    def bind_connect_server(_arg0, _arg1, _arg2, _arg3); end

    # Cancel a timer (can be a callback or an {EventMachine::Timer} instance).
    #
    # @param timer_or_sig [#cancel, #call] A timer to cancel
    # @see EventMachine::Timer#cancel
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:363
    def cancel_timer(timer_or_sig); end

    # Clean up Ruby space following a release_machine
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:261
    def cleanup_machine; end

    # @private
    def close_connection(_arg0, _arg1); end

    # Initiates a TCP connection to a remote server and sets up event handling for the connection.
    # {EventMachine.connect} requires event loop to be running (see {EventMachine.run}).
    #
    # {EventMachine.connect} takes the IP address (or hostname) and
    # port of the remote server you want to connect to.
    # It also takes an optional handler (a module or a subclass of {EventMachine::Connection}) which you must define, that
    # contains the callbacks that will be invoked by the event loop on behalf of the connection.
    #
    # Learn more about connection lifecycle callbacks in the {file:docs/GettingStarted.md EventMachine tutorial} and
    # {file:docs/ConnectionLifecycleCallbacks.md Connection lifecycle guide}.
    #
    # @example
    #
    #   # Here's a program which connects to a web server, sends a naive
    #   # request, parses the HTTP header of the response, and then
    #   # (antisocially) ends the event loop, which automatically drops the connection
    #   # (and incidentally calls the connection's unbind method).
    #   module DumbHttpClient
    #   def post_init
    #   send_data "GET / HTTP/1.1\r\nHost: _\r\n\r\n"
    #   @data = ""
    #   @parsed = false
    #   end
    #
    #   def receive_data data
    #   @data << data
    #   if !@parsed and @data =~ /[\n][\r]*[\n]/m
    #   @parsed = true
    #   puts "RECEIVED HTTP HEADER:"
    #   $`.each {|line| puts ">>> #{line}" }
    #
    #   puts "Now we'll terminate the loop, which will also close the connection"
    #   EventMachine::stop_event_loop
    #   end
    #   end
    #
    #   def unbind
    #   puts "A connection has terminated"
    #   end
    #   end
    #
    #   EventMachine.run {
    #   EventMachine.connect "www.bayshorenetworks.com", 80, DumbHttpClient
    #   }
    #   puts "The event loop has ended"
    # @example Defining protocol handler as a class
    #
    #   class MyProtocolHandler < EventMachine::Connection
    #   def initialize *args
    #   super
    #   # whatever else you want to do here
    #   end
    #
    #   # ...
    #   end
    # @param server [String] Host to connect to
    # @param port [Integer] Port to connect to
    # @param handler [Module, Class] A module or class that implements connection lifecycle callbacks
    # @see EventMachine.start_server
    # @see file:docs/GettingStarted.md EventMachine tutorial
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:631
    def connect(server, port = T.unsafe(nil), handler = T.unsafe(nil), *args, &blk); end

    # @private
    def connect_server(_arg0, _arg1); end

    # Make a connection to a Unix-domain socket. This method is simply an alias for {.connect},
    # which can connect to both TCP and Unix-domain sockets. Make sure that your process has sufficient
    # permissions to open the socket it is given.
    #
    # @note UNIX sockets, as the name suggests, are not available on Microsoft Windows.
    # @param socketname [String] Unix domain socket (local fully-qualified path) you want to connect to.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:813
    def connect_unix_domain(socketname, *args, &blk); end

    # @private
    def connect_unix_server(_arg0); end

    # Returns the total number of connections (file descriptors) currently held by the reactor.
    # Note that a tick must pass after the 'initiation' of a connection for this number to increment.
    # It's usually accurate, but don't rely on the exact precision of this number unless you really know EM internals.
    #
    # @example
    #
    #   EventMachine.run {
    #   EventMachine.connect("rubyeventmachine.com", 80)
    #   # count will be 0 in this case, because connection is not
    #   # established yet
    #   count = EventMachine.connection_count
    #   }
    # @example
    #
    #   EventMachine.run {
    #   EventMachine.connect("rubyeventmachine.com", 80)
    #
    #   EventMachine.next_tick {
    #   # In this example, count will be 1 since the connection has been established in
    #   # the next loop of the reactor.
    #   count = EventMachine.connection_count
    #   }
    #   }
    # @return [Integer] Number of connections currently held by the reactor.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:955
    def connection_count; end

    # @return [Boolean]
    def connection_paused?(_arg0); end

    def current_time; end

    # EventMachine.defer is used for integrating blocking operations into EventMachine's control flow.
    # The action of {.defer} is to take the block specified in the first parameter (the "operation")
    # and schedule it for asynchronous execution on an internal thread pool maintained by EventMachine.
    # When the operation completes, it will pass the result computed by the block (if any) back to the
    # EventMachine reactor. Then, EventMachine calls the block specified in the second parameter to
    # {.defer} (the "callback"), as part of its normal event handling loop. The result computed by the
    # operation block is passed as a parameter to the callback. You may omit the callback parameter if
    # you don't need to execute any code after the operation completes. If the operation raises an
    # unhandled exception, the exception will be passed to the third parameter to {.defer} (the
    # "errback"), as part of its normal event handling loop. If no errback is provided, the exception
    # will be allowed to blow through to the main thread immediately.
    #
    # ## Caveats ##
    #
    # Note carefully that the code in your deferred operation will be executed on a separate
    # thread from the main EventMachine processing and all other Ruby threads that may exist in
    # your program. Also, multiple deferred operations may be running at once! Therefore, you
    # are responsible for ensuring that your operation code is threadsafe.
    #
    # Don't write a deferred operation that will block forever. If so, the current implementation will
    # not detect the problem, and the thread will never be returned to the pool. EventMachine limits
    # the number of threads in its pool, so if you do this enough times, your subsequent deferred
    # operations won't get a chance to run.
    #
    # The threads within the EventMachine's thread pool have abort_on_exception set to true. As a result,
    # if an unhandled exception is raised by the deferred operation and an errback is not provided, it
    # will blow through to the main thread immediately. If the main thread is within an indiscriminate
    # rescue block at that time, the exception could be handled improperly by the main thread.
    #
    # @example
    #
    #   operation = proc {
    #   # perform a long-running operation here, such as a database query.
    #   "result" # as usual, the last expression evaluated in the block will be the return value.
    #   }
    #   callback = proc {|result|
    #   # do something with result here, such as send it back to a network client.
    #   }
    #   errback = proc {|error|
    #   # do something with error here, such as re-raising or logging.
    #   }
    #
    #   EventMachine.defer(operation, callback, errback)
    # @param op [#call] An operation you want to offload to EventMachine thread pool
    # @param callback [#call] A callback that will be run on the event loop thread after `operation` finishes.
    # @param errback [#call] An errback that will be run on the event loop thread after `operation` raises an exception.
    # @see EventMachine.threadpool_size
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1043
    def defer(op = T.unsafe(nil), callback = T.unsafe(nil), errback = T.unsafe(nil), &blk); end

    # Returns +true+ if all deferred actions are done executing and their
    # callbacks have been fired.
    #
    # @return [Boolean]
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1095
    def defers_finished?; end

    def detach_fd(_arg0); end

    # Takes just one argument, a {Connection} that has proxying enabled via {EventMachine.enable_proxy}.
    # Calling this method will remove that functionality and your connection will begin receiving
    # data via {Connection#receive_data} again.
    #
    # @param from [EventMachine::Connection] Source of data that is being proxied
    # @see EventMachine.enable_proxy
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1440
    def disable_proxy(from); end

    # This method allows for direct writing of incoming data back out to another descriptor, at the C++ level in the reactor.
    # This is very efficient and especially useful for proxies where high performance is required. Propogating data from a server response
    # all the way up to Ruby, and then back down to the reactor to be sent back to the client, is often unnecessary and
    # incurs a significant performance decrease.
    #
    # The two arguments are instance of {EventMachine::Connection} subclasses, 'from' and 'to'. 'from' is the connection whose inbound data you want
    # relayed back out. 'to' is the connection to write it to.
    #
    # Once you call this method, the 'from' connection will no longer get receive_data callbacks from the reactor,
    # except in the case that 'to' connection has already closed when attempting to write to it. You can see
    # in the example, that proxy_target_unbound will be called when this occurs. After that, further incoming
    # data will be passed into receive_data as normal.
    #
    # Note also that this feature supports different types of descriptors: TCP, UDP, and pipes. You can relay
    # data from one kind to another, for example, feed a pipe from a UDP stream.
    #
    # @example
    #
    #   module ProxyConnection
    #   def initialize(client, request)
    #   @client, @request = client, request
    #   end
    #
    #   def post_init
    #   EM::enable_proxy(self, @client)
    #   end
    #
    #   def connection_completed
    #   send_data @request
    #   end
    #
    #   def proxy_target_unbound
    #   close_connection
    #   end
    #
    #   def unbind
    #   @client.close_connection_after_writing
    #   end
    #   end
    #
    #   module ProxyServer
    #   def receive_data(data)
    #   (@buf ||= "") << data
    #   if @buf =~ /\r\n\r\n/ # all http headers received
    #   EventMachine.connect("10.0.0.15", 80, ProxyConnection, self, data)
    #   end
    #   end
    #   end
    #
    #   EventMachine.run {
    #   EventMachine.start_server("127.0.0.1", 8080, ProxyServer)
    #   }
    # @param from [EventMachine::Connection] Source of data to be proxies/streamed.
    # @param to [EventMachine::Connection] Destination of data to be proxies/streamed.
    # @param bufsize [Integer] Buffer size to use
    # @param length [Integer] Maximum number of bytes to proxy.
    # @see EventMachine.disable_proxy
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1430
    def enable_proxy(from, to, bufsize = T.unsafe(nil), length = T.unsafe(nil)); end

    # This method is a harmless no-op in the pure-Ruby implementation. This is intended to ensure
    # that user code behaves properly across different EM implementations.
    #
    # @private
    def epoll; end

    # Epoll is a no-op for Java.
    # The latest Java versions run epoll when possible in NIO.
    def epoll=(_arg0); end

    # @return [Boolean]
    def epoll?; end

    # Catch-all for errors raised during event loop callbacks.
    #
    # @example
    #
    #   EventMachine.error_handler{ |e|
    #   puts "Error raised during event loop: #{e.message}"
    #   }
    # @param cb [#call] Global catch-all errback
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1363
    def error_handler(cb = T.unsafe(nil), &blk); end

    # @private
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1463
    def event_callback(conn_binding, opcode, data); end

    # Forks a new process, properly stops the reactor and then calls {EventMachine.run} inside of it again, passing your block.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:243
    def fork_reactor(&block); end

    def get_cipher_bits(_arg0); end
    def get_cipher_name(_arg0); end
    def get_cipher_protocol(_arg0); end
    def get_comm_inactivity_timeout(_arg0); end
    def get_connection_count; end
    def get_file_descriptor(_arg0); end
    def get_heartbeat_interval; end
    def get_idle_time(_arg0); end
    def get_max_timer_count; end

    # Gets the current maximum number of allowed timers
    #
    # @return [Integer] Maximum number of timers that may be outstanding at any given time
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:924
    def get_max_timers; end

    def get_peer_cert(_arg0); end

    # @private
    def get_peername(_arg0); end

    def get_pending_connect_timeout(_arg0); end
    def get_proxied_bytes(_arg0); end
    def get_simultaneous_accept_count; end
    def get_sni_hostname(_arg0); end

    # @private
    def get_sock_opt(_arg0, _arg1, _arg2); end

    # @private
    def get_sockname(_arg0); end

    def get_subprocess_pid(_arg0); end
    def get_subprocess_status(_arg0); end

    # Retrieve the heartbeat interval. This is how often EventMachine will check for dead connections
    # that have had an inactivity timeout set via {Connection#set_comm_inactivity_timeout}.
    # Default is 2 seconds.
    #
    # @return [Integer] Heartbeat interval, in seconds
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1449
    def heartbeat_interval; end

    # Set the heartbeat interval. This is how often EventMachine will check for dead connections
    # that have had an inactivity timeout set via {Connection#set_comm_inactivity_timeout}.
    # Takes a Numeric number of seconds. Default is 2.
    #
    # @param time [Integer] Heartbeat interval, in seconds
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1458
    def heartbeat_interval=(time); end

    # @private
    def initialize_event_machine; end

    def invoke_popen(_arg0); end
    def is_notify_readable(_arg0); end
    def is_notify_writable(_arg0); end

    # @private
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1574
    def klass_from_handler(klass = T.unsafe(nil), handler = T.unsafe(nil), *args); end

    def kqueue; end
    def kqueue=(_arg0); end

    # @return [Boolean]
    def kqueue?; end

    # This is mostly useful for automated tests.
    # Return a distinctive symbol so the caller knows whether he's dealing
    # with an extension or with a pure-Ruby library.
    #
    # @private
    def library_type; end

    # Schedules a proc for execution immediately after the next "turn" through the reactor
    # core. An advanced technique, this can be useful for improving memory management and/or
    # application responsiveness, especially when scheduling large amounts of data for
    # writing to a network connection.
    #
    # This method takes either a single argument (which must be a callable object) or a block.
    #
    # @param pr [#call] A callable object to run
    # @raise [ArgumentError]
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1121
    def next_tick(pr = T.unsafe(nil), &block); end

    def num_close_scheduled; end

    # Used for UDP-based protocols. Its usage is similar to that of {EventMachine.start_server}.
    #
    # This method will create a new UDP (datagram) socket and
    # bind it to the address and port that you specify.
    # The normal callbacks (see {EventMachine.start_server}) will
    # be called as events of interest occur on the newly-created
    # socket, but there are some differences in how they behave.
    #
    # {Connection#receive_data} will be called when a datagram packet
    # is received on the socket, but unlike TCP sockets, the message
    # boundaries of the received data will be respected. In other words,
    # if the remote peer sent you a datagram of a particular size,
    # you may rely on {Connection#receive_data} to give you the
    # exact data in the packet, with the original data length.
    # Also observe that Connection#receive_data may be called with a
    # *zero-length* data payload, since empty datagrams are permitted in UDP.
    #
    # {Connection#send_data} is available with UDP packets as with TCP,
    # but there is an important difference. Because UDP communications
    # are *connectionless*, there is no implicit recipient for the packets you
    # send. Ordinarily you must specify the recipient for each packet you send.
    # However, EventMachine provides for the typical pattern of receiving a UDP datagram
    # from a remote peer, performing some operation, and then sending
    # one or more packets in response to the same remote peer.
    # To support this model easily, just use {Connection#send_data}
    # in the code that you supply for {Connection#receive_data}.
    #
    # EventMachine will provide an implicit return address for any messages sent to
    # {Connection#send_data} within the context of a {Connection#receive_data} callback,
    # and your response will automatically go to the correct remote peer.
    #
    # Observe that the port number that you supply to {EventMachine.open_datagram_socket}
    # may be zero. In this case, EventMachine will create a UDP socket
    # that is bound to an [ephemeral port](http://en.wikipedia.org/wiki/Ephemeral_port).
    # This is not appropriate for servers that must publish a well-known
    # port to which remote peers may send datagrams. But it can be useful
    # for clients that send datagrams to other servers.
    # If you do this, you will receive any responses from the remote
    # servers through the normal {Connection#receive_data} callback.
    # Observe that you will probably have issues with firewalls blocking
    # the ephemeral port numbers, so this technique is most appropriate for LANs.
    #
    # If you wish to send datagrams to arbitrary remote peers (not
    # necessarily ones that have sent data to which you are responding),
    # then see {Connection#send_datagram}.
    #
    # DO NOT call send_data from a datagram socket outside of a {Connection#receive_data} method. Use {Connection#send_datagram}.
    # If you do use {Connection#send_data} outside of a {Connection#receive_data} method, you'll get a confusing error
    # because there is no "peer," as #send_data requires (inside of {EventMachine::Connection#receive_data},
    # {EventMachine::Connection#send_data} "fakes" the peer as described above).
    #
    # @param address [String] IP address
    # @param port [String] Port
    # @param handler [Class, Module] A class or a module that implements connection lifecycle callbacks.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:872
    def open_datagram_socket(address, port, handler = T.unsafe(nil), *args); end

    # (Experimental)
    #
    # @private
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1235
    def open_keyboard(handler = T.unsafe(nil), *args); end

    # @private
    def open_udp_socket(_arg0, _arg1); end

    def pause_connection(_arg0); end

    # Runs an external process.
    #
    # @example
    #
    #   module RubyCounter
    #   def post_init
    #   # count up to 5
    #   send_data "5\n"
    #   end
    #   def receive_data data
    #   puts "ruby sent me: #{data}"
    #   end
    #   def unbind
    #   puts "ruby died with exit status: #{get_status.exitstatus}"
    #   end
    #   end
    #
    #   EventMachine.run {
    #   EventMachine.popen("ruby -e' $stdout.sync = true; gets.to_i.times{ |i| puts i+1; sleep 1 } '", RubyCounter)
    #   }
    # @note This method is not supported on Microsoft Windows
    # @see EventMachine::DeferrableChildProcess
    # @see EventMachine.system
    # @yield [c]
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1198
    def popen(cmd, handler = T.unsafe(nil), *args); end

    # Tells you whether the EventMachine reactor loop is currently running.
    #
    # Useful when writing libraries that want to run event-driven code, but may
    # be running in programs that are already event-driven. In such cases, if {EventMachine.reactor_running?}
    # returns false, your code can invoke {EventMachine.run} and run your application code inside
    # the block passed to that method. If this method returns true, just
    # execute your event-aware code.
    #
    # @return [Boolean] true if the EventMachine reactor loop is currently running
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1227
    def reactor_running?; end

    # Exposed to allow joining on the thread, when run in a multithreaded
    # environment. Performing other actions on the thread has undefined
    # semantics (read: a dangerous endevor).
    #
    # @return [Thread]
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:79
    def reactor_thread; end

    # @return [Boolean] true if the calling thread is the same thread as the reactor.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:227
    def reactor_thread?; end

    # @private
    def read_keyboard; end

    # Connect to a given host/port and re-use the provided {EventMachine::Connection} instance.
    # Consider also {EventMachine::Connection#reconnect}.
    #
    # @see EventMachine::Connection#reconnect
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:781
    def reconnect(server, port, handler); end

    # @private
    def release_machine; end

    # @private
    def report_connection_error_status(_arg0); end

    def resume_connection(_arg0); end

    # Initializes and runs an event loop. This method only returns if code inside the block passed to this method
    # calls {EventMachine.stop_event_loop}. The block is executed after initializing its internal event loop but *before* running the loop,
    # therefore this block is the right place to call any code that needs event loop to run, for example, {EventMachine.start_server},
    # {EventMachine.connect} or similar methods of libraries that use EventMachine under the hood
    # (like `EventMachine::HttpRequest.new` or `AMQP.start`).
    #
    # Programs that are run for long periods of time (e.g. servers) usually start event loop by calling {EventMachine.run}, and let it
    # run "forever". It's also possible to use {EventMachine.run} to make a single client-connection to a remote server,
    # process the data flow from that single connection, and then call {EventMachine.stop_event_loop} to stop, in other words,
    # to run event loop for a short period of time (necessary to complete some operation) and then shut it down.
    #
    # Once event loop is running, it is perfectly possible to start multiple servers and clients simultaneously: content-aware
    # proxies like [Proxymachine](https://github.com/mojombo/proxymachine) do just that.
    #
    # ## Using EventMachine with Ruby on Rails and other Web application frameworks ##
    #
    # Standalone applications often run event loop on the main thread, thus blocking for their entire lifespan. In case of Web applications,
    # if you are running an EventMachine-based app server such as [Thin](http://code.macournoyer.com/thin/) or [Goliath](https://github.com/postrank-labs/goliath/),
    # they start event loop for you. Servers like Unicorn, Apache Passenger or Mongrel occupy main Ruby thread to serve HTTP(S) requests. This means
    # that calling {EventMachine.run} on the same thread is not an option (it will result in Web server never binding to the socket).
    # In that case, start event loop in a separate thread as demonstrated below.
    #
    # @example Starting EventMachine event loop in the current thread to run the "Hello, world"-like Echo server example
    #
    #   #!/usr/bin/env ruby
    #
    #   require 'rubygems' # or use Bundler.setup
    #   require 'eventmachine'
    #
    #   class EchoServer < EM::Connection
    #   def receive_data(data)
    #   send_data(data)
    #   end
    #   end
    #
    #   EventMachine.run do
    #   EventMachine.start_server("0.0.0.0", 10000, EchoServer)
    #   end
    # @example Starting EventMachine event loop in a separate thread
    #
    #   # doesn't block current thread, can be used with Ruby on Rails, Sinatra, Merb, Rack
    #   # and any other application server that occupies main Ruby thread.
    #   Thread.new { EventMachine.run }
    # @note This method blocks calling thread. If you need to start EventMachine event loop from a Web app
    #   running on a non event-driven server (Unicorn, Apache Passenger, Mongrel), do it in a separate thread like demonstrated
    #   in one of the examples.
    # @see file:docs/GettingStarted.md Getting started with EventMachine
    # @see EventMachine.stop_event_loop
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:149
    def run(blk = T.unsafe(nil), tail = T.unsafe(nil), &block); end

    # Sugars a common use case. Will pass the given block to #run, but will terminate
    # the reactor loop and exit the function as soon as the code in the block completes.
    # (Normally, {EventMachine.run} keeps running indefinitely, even after the block supplied to it
    # finishes running, until user code calls {EventMachine.stop})
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:218
    def run_block(&block); end

    # The is the responder for the loopback-signalled event.
    # It can be fired either by code running on a separate thread ({EventMachine.defer}) or on
    # the main thread ({EventMachine.next_tick}).
    # It will often happen that a next_tick handler will reschedule itself. We
    # consume a copy of the tick queue so that tick events scheduled by tick events
    # have to wait for the next pass through the reactor core.
    #
    # @private
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:967
    def run_deferred_callbacks; end

    # @private
    def run_machine; end

    def run_machine_once; end
    def run_machine_without_threads; end

    # Runs the given callback on the reactor thread, or immediately if called
    # from the reactor thread. Accepts the same arguments as {EventMachine::Callback}
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:233
    def schedule(*a, &b); end

    # @private
    def send_data(_arg0, _arg1, _arg2); end

    # This is currently only for UDP!
    # We need to make it work with unix-domain sockets as well.
    #
    # @private
    def send_datagram(_arg0, _arg1, _arg2, _arg3, _arg4); end

    # @private
    def send_file_data(_arg0, _arg1); end

    # @private
    def set_comm_inactivity_timeout(_arg0, _arg1); end

    # Sets the maximum number of file or socket descriptors that your process may open.
    # If you call this method with no arguments, it will simply return
    # the current size of the descriptor table without attempting to change it.
    #
    # The new limit on open descriptors **only** applies to sockets and other descriptors
    # that belong to EventMachine. It has **no effect** on the number of descriptors
    # you can create in ordinary Ruby code.
    #
    # Not available on all platforms. Increasing the number of descriptors beyond its
    # default limit usually requires superuser privileges. (See {.set_effective_user}
    # for a way to drop superuser privileges while your program is running.)
    #
    # @param n_descriptors [Integer] The maximum number of file or socket descriptors that your process may open
    # @return [Integer] The new descriptor table size.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1168
    def set_descriptor_table_size(n_descriptors = T.unsafe(nil)); end

    # A wrapper over the setuid system call. Particularly useful when opening a network
    # server on a privileged port because you can use this call to drop privileges
    # after opening the port. Also very useful after a call to {.set_descriptor_table_size},
    # which generally requires that you start your process with root privileges.
    #
    # This method is intended for use in enforcing security requirements, consequently
    # it will throw a fatal error and end your program if it fails.
    #
    # @note This method has no effective implementation on Windows or in the pure-Ruby
    #   implementation of EventMachine
    # @param username [String] The effective name of the user whose privilege-level your process should attain.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1149
    def set_effective_user(username); end

    def set_heartbeat_interval(_arg0); end

    # This method is a harmless no-op in pure Ruby, which doesn't have a built-in limit
    # on the number of available timers.
    #
    # @private
    def set_max_timer_count(_arg0); end

    # Sets the maximum number of timers and periodic timers that may be outstanding at any
    # given time. You only need to call {.set_max_timers} if you need more than the default
    # number of timers, which on most platforms is 1000.
    #
    # @note This method has to be used *before* event loop is started.
    # @param ct [Integer] Maximum number of timers that may be outstanding at any given time
    # @see EventMachine.add_timer
    # @see EventMachine.add_periodic_timer
    # @see EventMachine::Timer
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:917
    def set_max_timers(ct); end

    def set_notify_readable(_arg0, _arg1); end
    def set_notify_writable(_arg0, _arg1); end

    # @private
    def set_pending_connect_timeout(_arg0, _arg1); end

    # For advanced users. This function sets the default timer granularity, which by default is
    # slightly smaller than 100 milliseconds. Call this function to set a higher or lower granularity.
    # The function affects the behavior of {EventMachine.add_timer} and {EventMachine.add_periodic_timer}.
    # Most applications will not need to call this function.
    #
    # Avoid setting the quantum to very low values because that may reduce performance under some extreme conditions.
    # We recommend that you not use values lower than 10.
    #
    # This method only can be used if event loop is running.
    #
    # @param mills [Integer] New timer granularity, in milliseconds
    # @see EventMachine.add_timer
    # @see EventMachine.add_periodic_timer
    # @see EventMachine::Timer
    # @see EventMachine.run
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:902
    def set_quantum(mills); end

    # This method is a no-op in the pure-Ruby implementation. We simply return Ruby's built-in
    # per-process file-descriptor limit.
    #
    # @private
    def set_rlimit_nofile(_arg0); end

    def set_simultaneous_accept_count(_arg0); end

    # @private
    def set_sock_opt(_arg0, _arg1, _arg2, _arg3); end

    # Sets reactor quantum in milliseconds. The underlying Reactor function wants a (possibly
    # fractional) number of seconds.
    #
    # @private
    def set_timer_quantum(_arg0); end

    # This method takes a series of positional arguments for specifying such
    # things as private keys and certificate chains. It's expected that the
    # parameter list will grow as we add more supported features. ALL of these
    # parameters are optional, and can be specified as empty or nil strings.
    #
    # @private
    def set_tls_parms(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9); end

    def setuid_string(_arg0); end

    # @private
    def signal_loopbreak; end

    # Spawn an erlang-style process
    #
    # source://eventmachine-1.2.7/lib/em/spawnable.rb:69
    def spawn(&block); end

    # @private
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1065
    def spawn_threadpool; end

    # @private
    # @return [Boolean]
    def ssl?; end

    def start_proxy(_arg0, _arg1, _arg2, _arg3); end

    # Initiates a TCP server (socket acceptor) on the specified IP address and port.
    #
    # The IP address must be valid on the machine where the program
    # runs, and the process must be privileged enough to listen
    # on the specified port (on Unix-like systems, superuser privileges
    # are usually required to listen on any port lower than 1024).
    # Only one listener may be running on any given address/port
    # combination. start_server will fail if the given address and port
    # are already listening on the machine, either because of a prior call
    # to {.start_server} or some unrelated process running on the machine.
    # If {.start_server} succeeds, the new network listener becomes active
    # immediately and starts accepting connections from remote peers,
    # and these connections generate callback events that are processed
    # by the code specified in the handler parameter to {.start_server}.
    #
    # The optional handler which is passed to this method is the key
    # to EventMachine's ability to handle particular network protocols.
    # The handler parameter passed to start_server must be a Ruby Module
    # that you must define. When the network server that is started by
    # start_server accepts a new connection, it instantiates a new
    # object of an anonymous class that is inherited from {EventMachine::Connection},
    # *into which your handler module have been included*. Arguments passed into start_server
    # after the class name are passed into the constructor during the instantiation.
    #
    # Your handler module may override any of the methods in {EventMachine::Connection},
    # such as {EventMachine::Connection#receive_data}, in order to implement the specific behavior
    # of the network protocol.
    #
    # Callbacks invoked in response to network events *always* take place
    # within the execution context of the object derived from {EventMachine::Connection}
    # extended by your handler module. There is one object per connection, and
    # all of the callbacks invoked for a particular connection take the form
    # of instance methods called against the corresponding {EventMachine::Connection}
    # object. Therefore, you are free to define whatever instance variables you
    # wish, in order to contain the per-connection state required by the network protocol you are
    # implementing.
    #
    # {EventMachine.start_server} is usually called inside the block passed to {EventMachine.run},
    # but it can be called from any EventMachine callback. {EventMachine.start_server} will fail
    # unless the EventMachine event loop is currently running (which is why
    # it's often called in the block suppled to {EventMachine.run}).
    #
    # You may call start_server any number of times to start up network
    # listeners on different address/port combinations. The servers will
    # all run simultaneously. More interestingly, each individual call to start_server
    # can specify a different handler module and thus implement a different
    # network protocol from all the others.
    #
    # @example
    #
    #   require 'rubygems'
    #   require 'eventmachine'
    #
    #   # Here is an example of a server that counts lines of input from the remote
    #   # peer and sends back the total number of lines received, after each line.
    #   # Try the example with more than one client connection opened via telnet,
    #   # and you will see that the line count increments independently on each
    #   # of the client connections. Also very important to note, is that the
    #   # handler for the receive_data function, which our handler redefines, may
    #   # not assume that the data it receives observes any kind of message boundaries.
    #   # Also, to use this example, be sure to change the server and port parameters
    #   # to the start_server call to values appropriate for your environment.
    #   module LineCounter
    #   MaxLinesPerConnection = 10
    #
    #   def post_init
    #   puts "Received a new connection"
    #   @data_received = ""
    #   @line_count = 0
    #   end
    #
    #   def receive_data data
    #   @data_received << data
    #   while @data_received.slice!( /^[^\n]*[\n]/m )
    #   @line_count += 1
    #   send_data "received #{@line_count} lines so far\r\n"
    #   @line_count == MaxLinesPerConnection and close_connection_after_writing
    #   end
    #   end
    #   end
    #
    #   EventMachine.run {
    #   host, port = "192.168.0.100", 8090
    #   EventMachine.start_server host, port, LineCounter
    #   puts "Now accepting connections on address #{host}, port #{port}..."
    #   EventMachine.add_periodic_timer(10) { $stderr.write "*" }
    #   }
    # @note Don't forget that in order to bind to ports < 1024 on Linux, *BSD and Mac OS X your process must have superuser privileges.
    # @param server [String] Host to bind to.
    # @param port [Integer] Port to bind to.
    # @param handler [Module, Class] A module or class that implements connection callbacks
    # @see file:docs/GettingStarted.md EventMachine tutorial
    # @see EventMachine.stop_server
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:517
    def start_server(server, port = T.unsafe(nil), handler = T.unsafe(nil), *args, &block); end

    # @private
    def start_tcp_server(_arg0, _arg1); end

    def start_tls(_arg0); end

    # Start a Unix-domain server.
    #
    # Note that this is an alias for {EventMachine.start_server}, which can be used to start both
    # TCP and Unix-domain servers.
    #
    # @see EventMachine.start_server
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:561
    def start_unix_domain_server(filename, *args, &block); end

    # @private
    def start_unix_server(_arg0); end

    # @private
    def stop; end

    # Causes the processing loop to stop executing, which will cause all open connections and accepting servers
    # to be run down and closed. Connection termination callbacks added using {EventMachine.add_shutdown_hook}
    # will be called as part of running this method.
    #
    # When all of this processing is complete, the call to {EventMachine.run} which started the processing loop
    # will return and program flow will resume from the statement following {EventMachine.run} call.
    #
    # @example Stopping a running EventMachine event loop
    #
    #   require 'rubygems'
    #   require 'eventmachine'
    #
    #   module Redmond
    #   def post_init
    #   puts "We're sending a dumb HTTP request to the remote peer."
    #   send_data "GET / HTTP/1.1\r\nHost: www.microsoft.com\r\n\r\n"
    #   end
    #
    #   def receive_data data
    #   puts "We received #{data.length} bytes from the remote peer."
    #   puts "We're going to stop the event loop now."
    #   EventMachine::stop_event_loop
    #   end
    #
    #   def unbind
    #   puts "A connection has terminated."
    #   end
    #   end
    #
    #   puts "We're starting the event loop now."
    #   EventMachine.run {
    #   EventMachine.connect "www.microsoft.com", 80, Redmond
    #   }
    #   puts "The event loop has stopped."
    #
    #   # This program will produce approximately the following output:
    #   #
    #   # We're starting the event loop now.
    #   # We're sending a dumb HTTP request to the remote peer.
    #   # We received 1440 bytes from the remote peer.
    #   # We're going to stop the event loop now.
    #   # A connection has terminated.
    #   # The event loop has stopped.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:417
    def stop_event_loop; end

    def stop_proxy(_arg0); end

    # Stop a TCP server socket that was started with {EventMachine.start_server}.
    #
    # @see EventMachine.start_server
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:551
    def stop_server(signature); end

    # @private
    def stop_tcp_server(_arg0); end

    # @return [Boolean]
    def stopping?; end

    # EM::system is a simple wrapper for EM::popen. It is similar to Kernel::system, but requires a
    # single string argument for the command and performs no shell expansion.
    #
    # The block or proc passed to EM::system is called with two arguments: the output generated by the command,
    # and a Process::Status that contains information about the command's execution.
    #
    #  EM.run{
    #    EM.system('ls'){ |output,status| puts output if status.exitstatus == 0 }
    #  }
    #
    # You can also supply an additional proc to send some data to the process:
    #
    #  EM.run{
    #    EM.system('sh', proc{ |process|
    #      process.send_data("echo hello\n")
    #      process.send_data("exit\n")
    #    }, proc{ |out,status|
    #      puts(out)
    #    })
    #  }
    #
    # Like EventMachine.popen, EventMachine.system currently does not work on windows.
    # It returns the pid of the spawned process.
    #
    # source://eventmachine-1.2.7/lib/em/processes.rb:112
    def system(cmd, *args, &cb); end

    # @private
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1105
    def threadpool; end

    # Size of the EventMachine.defer threadpool (defaults to 20)
    #
    # @return [Number]
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1109
    def threadpool_size; end

    # Size of the EventMachine.defer threadpool (defaults to 20)
    #
    # @return [Number]
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1109
    def threadpool_size=(_arg0); end

    # Creates and immediately starts an EventMachine::TickLoop
    #
    # source://eventmachine-1.2.7/lib/em/tick_loop.rb:3
    def tick_loop(*a, &b); end

    def unwatch_filename(_arg0); end
    def unwatch_pid(_arg0); end

    # {EventMachine.watch} registers a given file descriptor or IO object with the eventloop. The
    # file descriptor will not be modified (it will remain blocking or non-blocking).
    #
    # The eventloop can be used to process readable and writable events on the file descriptor, using
    # {EventMachine::Connection#notify_readable=} and {EventMachine::Connection#notify_writable=}
    #
    # {EventMachine::Connection#notify_readable?} and {EventMachine::Connection#notify_writable?} can be used
    # to check what events are enabled on the connection.
    #
    # To detach the file descriptor, use {EventMachine::Connection#detach}
    #
    # @author Riham Aldakkak (eSpace Technologies)
    # @example
    #
    #   module SimpleHttpClient
    #   def notify_readable
    #   header = @io.readline
    #
    #   if header == "\r\n"
    #   # detach returns the file descriptor number (fd == @io.fileno)
    #   fd = detach
    #   end
    #   rescue EOFError
    #   detach
    #   end
    #
    #   def unbind
    #   EM.next_tick do
    #   # socket is detached from the eventloop, but still open
    #   data = @io.read
    #   end
    #   end
    #   end
    #
    #   EventMachine.run {
    #   sock = TCPSocket.new('site.com', 80)
    #   sock.write("GET / HTTP/1.0\r\n\r\n")
    #   conn = EventMachine.watch(sock, SimpleHttpClient)
    #   conn.notify_readable = true
    #   }
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:731
    def watch(io, handler = T.unsafe(nil), *args, &blk); end

    # EventMachine's file monitoring API. Currently supported are the following events
    # on individual files, using inotify on Linux systems, and kqueue for *BSD and Mac OS X:
    #
    # * File modified (written to)
    # * File moved/renamed
    # * File deleted
    #
    # EventMachine::watch_file takes a filename and a handler Module containing your custom callback methods.
    # This will setup the low level monitoring on the specified file, and create a new EventMachine::FileWatch
    # object with your Module mixed in. FileWatch is a subclass of {EventMachine::Connection}, so callbacks on this object
    # work in the familiar way. The callbacks that will be fired by EventMachine are:
    #
    # * file_modified
    # * file_moved
    # * file_deleted
    #
    # You can access the filename being monitored from within this object using {FileWatch#path}.
    #
    # When a file is deleted, {FileWatch#stop_watching} will be called after your file_deleted callback,
    # to clean up the underlying monitoring and remove EventMachine's reference to the now-useless {FileWatch} instance.
    # This will in turn call unbind, if you wish to use it.
    #
    # The corresponding system-level Errno will be raised when attempting to monitor non-existent files,
    # files with wrong permissions, or if an error occurs dealing with inotify/kqueue.
    #
    # @example
    #
    #   # Before running this example, make sure we have a file to monitor:
    #   # $ echo "bar" > /tmp/foo
    #
    #   module Handler
    #   def file_modified
    #   puts "#{path} modified"
    #   end
    #
    #   def file_moved
    #   puts "#{path} moved"
    #   end
    #
    #   def file_deleted
    #   puts "#{path} deleted"
    #   end
    #
    #   def unbind
    #   puts "#{path} monitoring ceased"
    #   end
    #   end
    #
    #   # for efficient file watching, use kqueue on Mac OS X
    #   EventMachine.kqueue = true if EventMachine.kqueue?
    #
    #   EventMachine.run {
    #   EventMachine.watch_file("/tmp/foo", Handler)
    #   }
    #
    #   # $ echo "baz" >> /tmp/foo    =>    "/tmp/foo modified"
    #   # $ mv /tmp/foo /tmp/oof      =>    "/tmp/foo moved"
    #   # $ rm /tmp/oof               =>    "/tmp/foo deleted"
    # @note The ability to pick up on the new filename after a rename is not yet supported.
    #   Calling #path will always return the filename you originally used.
    # @param filename [String] Local path to the file to watch.
    # @param handler [Class, Module] A class or module that implements event handlers associated with the file.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1309
    def watch_file(filename, handler = T.unsafe(nil), *args); end

    def watch_filename(_arg0); end
    def watch_pid(_arg0); end

    # EventMachine's process monitoring API. On Mac OS X and *BSD this method is implemented using kqueue.
    #
    # @example
    #
    #   module ProcessWatcher
    #   def process_exited
    #   put 'the forked child died!'
    #   end
    #   end
    #
    #   pid = fork{ sleep }
    #
    #   EventMachine.run {
    #   EventMachine.watch_process(pid, ProcessWatcher)
    #   EventMachine.add_timer(1){ Process.kill('TERM', pid) }
    #   }
    # @param pid [Integer] PID of the process to watch.
    # @param handler [Class, Module] A class or module that implements event handlers associated with the file.
    #
    # source://eventmachine-1.2.7/lib/eventmachine.rb:1340
    def watch_process(pid, handler = T.unsafe(nil), *args); end

    # @private
    #
    # source://eventmachine-1.2.7/lib/em/spawnable.rb:76
    def yield(&block); end

    # @private
    #
    # source://eventmachine-1.2.7/lib/em/spawnable.rb:81
    def yield_and_notify(&block); end
  end
end

# @private
EventMachine::ConnectionAccepted = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::ConnectionCompleted = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::ConnectionData = T.let(T.unsafe(nil), Integer)

# @private
class EventMachine::ConnectionError < ::RuntimeError; end

# @private
class EventMachine::ConnectionNotBound < ::RuntimeError; end

# @private
EventMachine::ConnectionNotifyReadable = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::ConnectionNotifyWritable = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::ConnectionUnbound = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::EM_PROTO_SSLv2 = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::EM_PROTO_SSLv3 = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::EM_PROTO_TLSv1 = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::EM_PROTO_TLSv1_1 = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::EM_PROTO_TLSv1_2 = T.let(T.unsafe(nil), Integer)

# System errnos
#
# @private
#
# source://eventmachine-1.2.7/lib/eventmachine.rb:90
EventMachine::ERRNOS = T.let(T.unsafe(nil), Hash)

class EventMachine::InvalidSignature < ::RuntimeError; end

# @private
EventMachine::LoopbreakSignalled = T.let(T.unsafe(nil), Integer)

class EventMachine::NoHandlerForAcceptedConnection < ::RuntimeError; end

# Alias for {EventMachine::Protocols}
#
# source://eventmachine-1.2.7/lib/eventmachine.rb:1601
EventMachine::P = EventMachine::Protocols

# @private
EventMachine::SslHandshakeCompleted = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::SslVerify = T.let(T.unsafe(nil), Integer)

# @private
EventMachine::TimerFired = T.let(T.unsafe(nil), Integer)

# @private
class EventMachine::UnknownTimerFired < ::RuntimeError; end

# @private
class EventMachine::Unsupported < ::RuntimeError; end

# source://eventmachine-1.2.7/lib/em/version.rb:2
EventMachine::VERSION = T.let(T.unsafe(nil), String)

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:83
class EventMachine::WebMockHttpClient < ::EventMachine::HttpClient
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:102
  def connection_completed; end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:151
  def get_response_cookie(name); end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:139
  def request_signature; end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:107
  def send_request(head, body); end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:90
  def setup(response, uri, error = T.unsafe(nil)); end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:143
  def stubbed_webmock_response; end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:125
  def unbind(reason = T.unsafe(nil)); end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:86
  def uri; end

  private

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:171
  def build_request_signature; end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:163
  def build_webmock_response; end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:198
  def make_raw_response(response); end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:54
class EventMachine::WebMockHttpConnection < ::EventMachine::HttpConnection
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:55
  def activate_connection(client); end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:78
  def drop_client; end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http_response.rb:16
module Net::WebMockHTTPResponse
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http_response.rb:17
  def read_body(dest = T.unsafe(nil), &block); end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:259
class Net::WebMockNetBufferedIO < ::Net::BufferedIO
  # @return [WebMockNetBufferedIO] a new instance of WebMockNetBufferedIO
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:260
  def initialize(io, *args, **kwargs); end

  # https://github.com/ruby/ruby/blob/7d02441f0d6e5c9d0a73a024519eba4f69e36dce/lib/net/protocol.rb#L208
  # Modified version of method from ruby, so that nil is always passed into orig_read_nonblock to avoid timeout
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:284
  def rbuf_fill; end
end

# patch for StringIO behavior in Ruby 2.2.3
# https://github.com/bblimke/webmock/issues/558
#
# source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:219
class PatchedStringIO < ::StringIO
  def orig_read_nonblock(*_arg0); end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:223
  def read_nonblock(size, *args, **kwargs); end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:230
class StubSocket
  # @return [StubSocket] a new instance of StubSocket
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:234
  def initialize(*args); end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:241
  def close; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:237
  def closed?; end

  # Returns the value of attribute continue_timeout.
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:232
  def continue_timeout; end

  # Sets the attribute continue_timeout
  #
  # @param value the value to set the attribute continue_timeout to.
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:232
  def continue_timeout=(_arg0); end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:247
  def io; end

  # Returns the value of attribute read_timeout.
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:232
  def read_timeout; end

  # Sets the attribute read_timeout
  #
  # @param value the value to set the attribute read_timeout to.
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:232
  def read_timeout=(_arg0); end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:244
  def readuntil(*args); end

  # Returns the value of attribute write_timeout.
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:232
  def write_timeout; end

  # Sets the attribute write_timeout
  #
  # @param value the value to set the attribute write_timeout to.
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:232
  def write_timeout=(_arg0); end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:251
class StubSocket::StubIO
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:253
  def peer_cert; end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:252
  def setsockopt(*args); end
end

# source://webmock-3.16.0/lib/webmock/deprecation.rb:1
module WebMock
  include ::WebMock::API
  extend ::WebMock::API

  def after_request(*args, &block); end
  def allow_net_connect!(*args, &block); end
  def disable_net_connect!(*args, &block); end
  def net_connect_allowed?(*args, &block); end
  def registered_request?(*args, &block); end
  def reset_callbacks(*args, &block); end
  def reset_webmock(*args, &block); end

  class << self
    # source://webmock-3.16.0/lib/webmock/webmock.rb:141
    def after_request(options = T.unsafe(nil), &block); end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:44
    def allow_net_connect!(options = T.unsafe(nil)); end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:28
    def disable!(options = T.unsafe(nil)); end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:49
    def disable_net_connect!(options = T.unsafe(nil)); end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:49
    def disallow_net_connect!(options = T.unsafe(nil)); end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:36
    def enable!(options = T.unsafe(nil)); end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:44
    def enable_net_connect!(options = T.unsafe(nil)); end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:153
    def globally_stub_request(order = T.unsafe(nil), &block); end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:107
    def hide_body_diff!; end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:115
    def hide_stubbing_instructions!; end

    # @private
    #
    # source://webmock-3.16.0/lib/webmock/webmock.rb:3
    def included(clazz); end

    # @return [Boolean]
    #
    # source://webmock-3.16.0/lib/webmock/webmock.rb:61
    def net_connect_allowed?(uri = T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://webmock-3.16.0/lib/webmock/webmock.rb:83
    def net_connect_explicit_allowed?(allowed, uri = T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://webmock-3.16.0/lib/webmock/webmock.rb:73
    def net_http_connect_on_start?(uri); end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:149
    def print_executed_requests; end

    # @return [Boolean]
    #
    # source://webmock-3.16.0/lib/webmock/webmock.rb:145
    def registered_request?(request_signature); end

    # source://webmock-3.16.0/lib/webmock/api.rb:12
    def request(method, uri); end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:127
    def reset!; end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:137
    def reset_callbacks; end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:132
    def reset_webmock; end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:103
    def show_body_diff!; end

    # @return [Boolean]
    #
    # source://webmock-3.16.0/lib/webmock/webmock.rb:111
    def show_body_diff?; end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:119
    def show_stubbing_instructions!; end

    # @return [Boolean]
    #
    # source://webmock-3.16.0/lib/webmock/webmock.rb:123
    def show_stubbing_instructions?; end

    # source://webmock-3.16.0/lib/webmock/webmock.rb:24
    def version; end
  end
end

# source://webmock-3.16.0/lib/webmock/api.rb:2
module WebMock::API
  extend ::WebMock::API

  # source://webmock-3.16.0/lib/webmock/api.rb:12
  def a_request(method, uri); end

  # source://webmock-3.16.0/lib/webmock/api.rb:29
  def assert_not_requested(*args, &block); end

  # source://webmock-3.16.0/lib/webmock/api.rb:20
  def assert_requested(*args, &block); end

  # source://webmock-3.16.0/lib/webmock/api.rb:57
  def hash_excluding(*args); end

  # Similar to RSpec::Mocks::ArgumentMatchers#hash_including()
  #
  # Matches a hash that includes the specified key(s) or key/value pairs.
  # Ignores any additional keys.
  #
  # @example
  #
  #   object.should_receive(:message).with(hash_including(:key => val))
  #   object.should_receive(:message).with(hash_including(:key))
  #   object.should_receive(:message).with(hash_including(:key, :key2 => val2))
  #
  # source://webmock-3.16.0/lib/webmock/api.rb:49
  def hash_including(*args); end

  # source://webmock-3.16.0/lib/webmock/api.rb:29
  def refute_requested(*args, &block); end

  # source://webmock-3.16.0/lib/webmock/api.rb:65
  def remove_request_stub(stub); end

  # source://webmock-3.16.0/lib/webmock/api.rb:69
  def reset_executed_requests!; end

  # source://webmock-3.16.0/lib/webmock/api.rb:5
  def stub_http_request(method, uri); end

  # source://webmock-3.16.0/lib/webmock/api.rb:5
  def stub_request(method, uri); end

  private

  # this is a based on RSpec::Mocks::ArgumentMatchers#anythingize_lonely_keys
  #
  # source://webmock-3.16.0/lib/webmock/api.rb:102
  def anythingize_lonely_keys(*args); end

  # source://webmock-3.16.0/lib/webmock/api.rb:93
  def assert_request_not_requested(request, options = T.unsafe(nil)); end

  # source://webmock-3.16.0/lib/webmock/api.rb:84
  def assert_request_requested(request, options = T.unsafe(nil)); end

  # source://webmock-3.16.0/lib/webmock/api.rb:75
  def convert_uri_method_and_options_to_request_and_options(method, uri, options, &block); end

  class << self
    # source://webmock-3.16.0/lib/webmock/api.rb:12
    def request(method, uri); end
  end
end

# source://webmock-3.16.0/lib/webmock/assertion_failure.rb:2
class WebMock::AssertionFailure
  class << self
    # Returns the value of attribute error_class.
    #
    # source://webmock-3.16.0/lib/webmock/assertion_failure.rb:5
    def error_class; end

    # Sets the attribute error_class
    #
    # @param value the value to set the attribute error_class to.
    #
    # source://webmock-3.16.0/lib/webmock/assertion_failure.rb:5
    def error_class=(_arg0); end

    # @raise [@error_class]
    #
    # source://webmock-3.16.0/lib/webmock/assertion_failure.rb:6
    def failure(message); end
  end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:250
class WebMock::BodyPattern
  include ::WebMock::RSpecMatcherDetector

  # @return [BodyPattern] a new instance of BodyPattern
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:268
  def initialize(pattern); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:278
  def matches?(body, content_type = T.unsafe(nil)); end

  # Returns the value of attribute pattern.
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:266
  def pattern; end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:293
  def to_s; end

  private

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:315
  def assert_non_multipart_body(content_type); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:299
  def body_as_hash(body, content_type); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:310
  def body_format(content_type); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:360
  def empty_string?(string); end

  # Compare two hashes for equality
  #
  # For two hashes to match they must have the same length and all
  # values must match when compared using `#===`.
  #
  # The following hashes are examples of matches:
  #
  #     {a: /\d+/} and {a: '123'}
  #
  #     {a: '123'} and {a: '123'}
  #
  #     {a: {b: /\d+/}} and {a: {b: '123'}}
  #
  #     {a: {b: 'wow'}} and {a: {b: 'wow'}}
  #
  # @param query_parameters [Hash] typically the result of parsing
  #   JSON, XML or URL encoded parameters.
  # @param pattern [Hash] which contains keys with a string, hash or
  #   regular expression value to use for comparison.
  # @return [Boolean] true if the paramaters match the comparison
  #   hash, false if not.
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:344
  def matching_body_hashes?(query_parameters, pattern, content_type); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:364
  def normalize_hash(hash); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:368
  def url_encoded_body?(content_type); end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:253
WebMock::BodyPattern::BODY_FORMATS = T.let(T.unsafe(nil), Hash)

# source://webmock-3.16.0/lib/webmock/callback_registry.rb:2
class WebMock::CallbackRegistry
  class << self
    # source://webmock-3.16.0/lib/webmock/callback_registry.rb:5
    def add_callback(options, block); end

    # @return [Boolean]
    #
    # source://webmock-3.16.0/lib/webmock/callback_registry.rb:30
    def any_callbacks?; end

    # source://webmock-3.16.0/lib/webmock/callback_registry.rb:9
    def callbacks; end

    # source://webmock-3.16.0/lib/webmock/callback_registry.rb:13
    def invoke_callbacks(options, request_signature, response); end

    # source://webmock-3.16.0/lib/webmock/callback_registry.rb:26
    def reset; end
  end
end

# source://webmock-3.16.0/lib/webmock/config.rb:2
class WebMock::Config
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [Config] a new instance of Config
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:5
  def initialize; end

  # Returns the value of attribute allow.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:12
  def allow; end

  # Sets the attribute allow
  #
  # @param value the value to set the attribute allow to.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:12
  def allow=(_arg0); end

  # Returns the value of attribute allow_localhost.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:11
  def allow_localhost; end

  # Sets the attribute allow_localhost
  #
  # @param value the value to set the attribute allow_localhost to.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:11
  def allow_localhost=(_arg0); end

  # Returns the value of attribute allow_net_connect.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:10
  def allow_net_connect; end

  # Sets the attribute allow_net_connect
  #
  # @param value the value to set the attribute allow_net_connect to.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:10
  def allow_net_connect=(_arg0); end

  # Returns the value of attribute net_http_connect_on_start.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:13
  def net_http_connect_on_start; end

  # Sets the attribute net_http_connect_on_start
  #
  # @param value the value to set the attribute net_http_connect_on_start to.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:13
  def net_http_connect_on_start=(_arg0); end

  # Returns the value of attribute query_values_notation.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:15
  def query_values_notation; end

  # Sets the attribute query_values_notation
  #
  # @param value the value to set the attribute query_values_notation to.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:15
  def query_values_notation=(_arg0); end

  # Returns the value of attribute show_body_diff.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:16
  def show_body_diff; end

  # Sets the attribute show_body_diff
  #
  # @param value the value to set the attribute show_body_diff to.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:16
  def show_body_diff=(_arg0); end

  # Returns the value of attribute show_stubbing_instructions.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:14
  def show_stubbing_instructions; end

  # Sets the attribute show_stubbing_instructions
  #
  # @param value the value to set the attribute show_stubbing_instructions to.
  #
  # source://webmock-3.16.0/lib/webmock/config.rb:14
  def show_stubbing_instructions=(_arg0); end
end

# source://webmock-3.16.0/lib/webmock/deprecation.rb:2
class WebMock::Deprecation
  class << self
    # source://webmock-3.16.0/lib/webmock/deprecation.rb:4
    def warning(message); end
  end
end

# source://webmock-3.16.0/lib/webmock/response.rb:147
class WebMock::DynamicResponse < ::WebMock::Response
  # @return [DynamicResponse] a new instance of DynamicResponse
  #
  # source://webmock-3.16.0/lib/webmock/response.rb:150
  def initialize(responder); end

  # source://webmock-3.16.0/lib/webmock/response.rb:154
  def evaluate(request_signature); end

  # Returns the value of attribute responder.
  #
  # source://webmock-3.16.0/lib/webmock/response.rb:148
  def responder; end

  # Sets the attribute responder
  #
  # @param value the value to set the attribute responder to.
  #
  # source://webmock-3.16.0/lib/webmock/response.rb:148
  def responder=(_arg0); end
end

# source://webmock-3.16.0/lib/webmock/util/hash_validator.rb:2
class WebMock::HashValidator
  # @return [HashValidator] a new instance of HashValidator
  #
  # source://webmock-3.16.0/lib/webmock/util/hash_validator.rb:3
  def initialize(hash); end

  # This code is based on https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/hash/keys.rb
  #
  # source://webmock-3.16.0/lib/webmock/util/hash_validator.rb:8
  def validate_keys(*valid_keys); end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:373
class WebMock::HeadersPattern
  # @return [HeadersPattern] a new instance of HeadersPattern
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:374
  def initialize(pattern); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:378
  def matches?(headers); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:394
  def pp_to_s; end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:390
  def to_s; end

  private

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:400
  def empty_headers?(headers); end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/http_lib_adapter.rb:2
class WebMock::HttpLibAdapter
  class << self
    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/http_lib_adapter.rb:3
    def adapter_for(lib); end
  end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/http_lib_adapter_registry.rb:2
class WebMock::HttpLibAdapterRegistry
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [HttpLibAdapterRegistry] a new instance of HttpLibAdapterRegistry
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/http_lib_adapter_registry.rb:7
  def initialize; end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/http_lib_adapter_registry.rb:15
  def each_adapter(&block); end

  # Returns the value of attribute http_lib_adapters.
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/http_lib_adapter_registry.rb:5
  def http_lib_adapters; end

  # Sets the attribute http_lib_adapters
  #
  # @param value the value to set the attribute http_lib_adapters to.
  #
  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/http_lib_adapter_registry.rb:5
  def http_lib_adapters=(_arg0); end

  # source://webmock-3.16.0/lib/webmock/http_lib_adapters/http_lib_adapter_registry.rb:11
  def register(lib, adapter); end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:8
module WebMock::HttpLibAdapters; end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:10
class WebMock::HttpLibAdapters::EmHttpRequestAdapter < ::WebMock::HttpLibAdapter
  class << self
    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:23
    def disable!; end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:16
    def enable!; end
  end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:13
WebMock::HttpLibAdapters::EmHttpRequestAdapter::OriginalHttpClient = EventMachine::HttpClient

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/em_http_request_adapter.rb:14
WebMock::HttpLibAdapters::EmHttpRequestAdapter::OriginalHttpConnection = EventMachine::HttpConnection

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:13
class WebMock::HttpLibAdapters::ExconAdapter < ::WebMock::HttpLibAdapter
  class << self
    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:35
    def add_excon_stub; end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:118
    def body_from(params); end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:108
    def build_request(params); end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:79
    def connection_params_from(hash); end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:31
    def disable!; end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:27
    def enable!; end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:52
    def handle_request(params); end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:138
    def mock_response(real); end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:72
    def new_excon_connection(params); end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:146
    def perform_callbacks(request, response, options = T.unsafe(nil)); end

    # @raise [Excon::Errors::Timeout]
    #
    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:127
    def real_response(mock); end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:45
    def remove_excon_stub; end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:85
    def request_params_from(hash); end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:94
    def to_query(hash); end
  end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/excon_adapter.rb:14
WebMock::HttpLibAdapters::ExconAdapter::PARAMS_TO_DELETE = T.let(T.unsafe(nil), Array)

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:9
class WebMock::HttpLibAdapters::NetHttpAdapter < ::WebMock::HttpLibAdapter
  class << self
    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:24
    def disable!; end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:15
    def enable!; end
  end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:13
WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetBufferedIO = Net::BufferedIO

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:12
WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetHTTP = Net::HTTP

# source://webmock-3.16.0/lib/webmock/matchers/hash_argument_matcher.rb:2
module WebMock::Matchers; end

# this is a based on RSpec::Mocks::ArgumentMatchers::AnyArgMatcher
#
# source://webmock-3.16.0/lib/webmock/matchers/any_arg_matcher.rb:4
class WebMock::Matchers::AnyArgMatcher
  # @return [AnyArgMatcher] a new instance of AnyArgMatcher
  #
  # source://webmock-3.16.0/lib/webmock/matchers/any_arg_matcher.rb:5
  def initialize(ignore); end

  # source://webmock-3.16.0/lib/webmock/matchers/any_arg_matcher.rb:8
  def ==(other); end
end

# Base class for Hash matchers
# https://github.com/rspec/rspec-mocks/blob/master/lib/rspec/mocks/argument_matchers.rb
#
# source://webmock-3.16.0/lib/webmock/matchers/hash_argument_matcher.rb:5
class WebMock::Matchers::HashArgumentMatcher
  # @return [HashArgumentMatcher] a new instance of HashArgumentMatcher
  #
  # source://webmock-3.16.0/lib/webmock/matchers/hash_argument_matcher.rb:6
  def initialize(expected); end

  # source://webmock-3.16.0/lib/webmock/matchers/hash_argument_matcher.rb:10
  def ==(_actual, &block); end

  class << self
    # source://webmock-3.16.0/lib/webmock/matchers/hash_argument_matcher.rb:16
    def from_rspec_matcher(matcher); end
  end
end

# this is a based on RSpec::Mocks::ArgumentMatchers::HashExcludingMatcher
# https://github.com/rspec/rspec-mocks/blob/master/lib/rspec/mocks/argument_matchers.rb
#
# source://webmock-3.16.0/lib/webmock/matchers/hash_excluding_matcher.rb:5
class WebMock::Matchers::HashExcludingMatcher < ::WebMock::Matchers::HashArgumentMatcher
  # source://webmock-3.16.0/lib/webmock/matchers/hash_excluding_matcher.rb:6
  def ==(actual); end

  # source://webmock-3.16.0/lib/webmock/matchers/hash_excluding_matcher.rb:10
  def inspect; end
end

# this is a based on RSpec::Mocks::ArgumentMatchers::HashIncludingMatcher
# https://github.com/rspec/rspec-mocks/blob/master/lib/rspec/mocks/argument_matchers.rb
#
# source://webmock-3.16.0/lib/webmock/matchers/hash_including_matcher.rb:5
class WebMock::Matchers::HashIncludingMatcher < ::WebMock::Matchers::HashArgumentMatcher
  # source://webmock-3.16.0/lib/webmock/matchers/hash_including_matcher.rb:6
  def ==(actual); end

  # source://webmock-3.16.0/lib/webmock/matchers/hash_including_matcher.rb:12
  def inspect; end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:93
class WebMock::MethodPattern
  # @return [MethodPattern] a new instance of MethodPattern
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:94
  def initialize(pattern); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:98
  def matches?(method); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:102
  def to_s; end
end

# source://webmock-3.16.0/lib/webmock/errors.rb:3
class WebMock::NetConnectNotAllowedError < ::Exception
  # @return [NetConnectNotAllowedError] a new instance of NetConnectNotAllowedError
  #
  # source://webmock-3.16.0/lib/webmock/errors.rb:4
  def initialize(request_signature); end
end

# source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:306
module WebMock::NetHTTPUtility
  class << self
    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:365
    def check_right_http_connection; end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:337
    def get_uri(net_http, path = T.unsafe(nil)); end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:369
    def puts_warning_for_right_http_if_needed; end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:308
    def request_signature_from_request(net_http, request, body = T.unsafe(nil)); end

    # source://webmock-3.16.0/lib/webmock/http_lib_adapters/net_http.rb:346
    def validate_headers(headers); end
  end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:3
module WebMock::RSpecMatcherDetector
  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:8
  def rSpecHashExcludingMatcher?(matcher); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:4
  def rSpecHashIncludingMatcher?(matcher); end
end

# source://webmock-3.16.0/lib/webmock/rack_response.rb:2
class WebMock::RackResponse < ::WebMock::Response
  # @return [RackResponse] a new instance of RackResponse
  #
  # source://webmock-3.16.0/lib/webmock/rack_response.rb:3
  def initialize(app); end

  # source://webmock-3.16.0/lib/webmock/rack_response.rb:19
  def body_from_rack_response(response); end

  # source://webmock-3.16.0/lib/webmock/rack_response.rb:26
  def build_rack_env(request); end

  # source://webmock-3.16.0/lib/webmock/rack_response.rb:7
  def evaluate(request); end

  # source://webmock-3.16.0/lib/webmock/rack_response.rb:61
  def session; end

  # source://webmock-3.16.0/lib/webmock/rack_response.rb:65
  def session_options; end
end

# source://webmock-3.16.0/lib/webmock/request_body_diff.rb:5
class WebMock::RequestBodyDiff
  # @return [RequestBodyDiff] a new instance of RequestBodyDiff
  #
  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:7
  def initialize(request_signature, request_stub); end

  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:12
  def body_diff; end

  private

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:55
  def parseable_json?(body_pattern); end

  # Returns the value of attribute request_signature.
  #
  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:18
  def request_signature; end

  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:31
  def request_signature_body_hash; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:23
  def request_signature_diffable?; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:47
  def request_signature_parseable_json?; end

  # Returns the value of attribute request_stub.
  #
  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:18
  def request_stub; end

  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:41
  def request_stub_body; end

  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:35
  def request_stub_body_hash; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:27
  def request_stub_diffable?; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_body_diff.rb:51
  def request_stub_parseable_json?; end
end

# source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:2
class WebMock::RequestExecutionVerifier
  # @return [RequestExecutionVerifier] a new instance of RequestExecutionVerifier
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:6
  def initialize(request_pattern = T.unsafe(nil), expected_times_executed = T.unsafe(nil), at_least_times_executed = T.unsafe(nil), at_most_times_executed = T.unsafe(nil)); end

  # Returns the value of attribute at_least_times_executed.
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:4
  def at_least_times_executed; end

  # Sets the attribute at_least_times_executed
  #
  # @param value the value to set the attribute at_least_times_executed to.
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:4
  def at_least_times_executed=(_arg0); end

  # Returns the value of attribute at_most_times_executed.
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:4
  def at_most_times_executed; end

  # Sets the attribute at_most_times_executed
  #
  # @param value the value to set the attribute at_most_times_executed to.
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:4
  def at_most_times_executed=(_arg0); end

  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:36
  def description; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:26
  def does_not_match?; end

  # Returns the value of attribute expected_times_executed.
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:4
  def expected_times_executed; end

  # Sets the attribute expected_times_executed
  #
  # @param value the value to set the attribute expected_times_executed to.
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:4
  def expected_times_executed=(_arg0); end

  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:40
  def failure_message; end

  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:44
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:13
  def matches?; end

  # Returns the value of attribute request_pattern.
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:4
  def request_pattern; end

  # Sets the attribute request_pattern
  #
  # @param value the value to set the attribute request_pattern to.
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:4
  def request_pattern=(_arg0); end

  # Returns the value of attribute times_executed.
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:4
  def times_executed; end

  # Sets the attribute times_executed
  #
  # @param value the value to set the attribute times_executed to.
  #
  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:4
  def times_executed=(_arg0); end

  private

  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:54
  def failure_message_phrase(is_negated = T.unsafe(nil)); end

  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:60
  def quantity_phrase(is_negated = T.unsafe(nil)); end

  # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:72
  def times(times); end

  class << self
    # source://webmock-3.16.0/lib/webmock/request_execution_verifier.rb:48
    def executed_requests_message; end
  end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:13
class WebMock::RequestPattern
  # @return [RequestPattern] a new instance of RequestPattern
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:17
  def initialize(method, uri, options = T.unsafe(nil)); end

  # Returns the value of attribute body_pattern.
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:15
  def body_pattern; end

  # Returns the value of attribute headers_pattern.
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:15
  def headers_pattern; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:33
  def matches?(request_signature); end

  # Returns the value of attribute method_pattern.
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:15
  def method_pattern; end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:43
  def to_s; end

  # Returns the value of attribute uri_pattern.
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:15
  def uri_pattern; end

  # @raise [ArgumentError]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:26
  def with(options = T.unsafe(nil), &block); end

  private

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:55
  def assign_options(options); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:78
  def create_uri_pattern(uri); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:64
  def set_basic_auth_as_headers!(options); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:72
  def validate_basic_auth!(basic_auth); end
end

# source://webmock-3.16.0/lib/webmock/request_registry.rb:3
class WebMock::RequestRegistry
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [RequestRegistry] a new instance of RequestRegistry
  #
  # source://webmock-3.16.0/lib/webmock/request_registry.rb:8
  def initialize; end

  # Returns the value of attribute requested_signatures.
  #
  # source://webmock-3.16.0/lib/webmock/request_registry.rb:6
  def requested_signatures; end

  # Sets the attribute requested_signatures
  #
  # @param value the value to set the attribute requested_signatures to.
  #
  # source://webmock-3.16.0/lib/webmock/request_registry.rb:6
  def requested_signatures=(_arg0); end

  # source://webmock-3.16.0/lib/webmock/request_registry.rb:12
  def reset!; end

  # source://webmock-3.16.0/lib/webmock/request_registry.rb:16
  def times_executed(request_pattern); end

  # source://webmock-3.16.0/lib/webmock/request_registry.rb:22
  def to_s; end
end

# source://webmock-3.16.0/lib/webmock/request_signature.rb:3
class WebMock::RequestSignature
  # @return [RequestSignature] a new instance of RequestSignature
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:8
  def initialize(method, uri, options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:32
  def ==(other); end

  # Returns the value of attribute body.
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:5
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:5
  def body=(_arg0); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:32
  def eql?(other); end

  # source://webmock-3.16.0/lib/webmock/request_signature.rb:28
  def hash; end

  # Returns the value of attribute headers.
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:6
  def headers; end

  # source://webmock-3.16.0/lib/webmock/request_signature.rb:24
  def headers=(headers); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:41
  def json_headers?; end

  # Returns the value of attribute method.
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:5
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:5
  def method=(_arg0); end

  # source://webmock-3.16.0/lib/webmock/request_signature.rb:14
  def to_s; end

  # Returns the value of attribute uri.
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:5
  def uri; end

  # Sets the attribute uri
  #
  # @param value the value to set the attribute uri to.
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:5
  def uri=(_arg0); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_signature.rb:37
  def url_encoded?; end

  private

  # source://webmock-3.16.0/lib/webmock/request_signature.rb:47
  def assign_options(options); end
end

# source://webmock-3.16.0/lib/webmock/request_signature_snippet.rb:4
class WebMock::RequestSignatureSnippet
  # @return [RequestSignatureSnippet] a new instance of RequestSignatureSnippet
  #
  # source://webmock-3.16.0/lib/webmock/request_signature_snippet.rb:8
  def initialize(request_signature); end

  # Returns the value of attribute request_signature.
  #
  # source://webmock-3.16.0/lib/webmock/request_signature_snippet.rb:6
  def request_signature; end

  # Returns the value of attribute request_stub.
  #
  # source://webmock-3.16.0/lib/webmock/request_signature_snippet.rb:6
  def request_stub; end

  # source://webmock-3.16.0/lib/webmock/request_signature_snippet.rb:20
  def request_stubs; end

  # source://webmock-3.16.0/lib/webmock/request_signature_snippet.rb:13
  def stubbing_instructions; end

  private

  # source://webmock-3.16.0/lib/webmock/request_signature_snippet.rb:33
  def add_body_diff(stub, text); end

  # source://webmock-3.16.0/lib/webmock/request_signature_snippet.rb:52
  def pretty_print_to_string(string_to_print); end

  # source://webmock-3.16.0/lib/webmock/request_signature_snippet.rb:43
  def request_params; end

  # source://webmock-3.16.0/lib/webmock/request_signature_snippet.rb:38
  def signature_stub_body_diff(stub); end
end

# source://webmock-3.16.0/lib/webmock/request_stub.rb:2
class WebMock::RequestStub
  # @return [RequestStub] a new instance of RequestStub
  #
  # source://webmock-3.16.0/lib/webmock/request_stub.rb:6
  def initialize(method, uri); end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:46
  def and_raise(*exceptions); end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:17
  def and_return(*response_hashes, &block); end

  # @raise [ArgumentError]
  #
  # source://webmock-3.16.0/lib/webmock/request_stub.rb:27
  def and_return_json(*response_hashes); end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:54
  def and_timeout; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_stub.rb:71
  def has_responses?; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_stub.rb:89
  def matches?(request_signature); end

  # Returns the value of attribute request_pattern.
  #
  # source://webmock-3.16.0/lib/webmock/request_stub.rb:4
  def request_pattern; end

  # Sets the attribute request_pattern
  #
  # @param value the value to set the attribute request_pattern to.
  #
  # source://webmock-3.16.0/lib/webmock/request_stub.rb:4
  def request_pattern=(_arg0); end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:60
  def response; end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:75
  def then; end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:79
  def times(number); end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:42
  def to_rack(app, options = T.unsafe(nil)); end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:46
  def to_raise(*exceptions); end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:17
  def to_return(*response_hashes, &block); end

  # @raise [ArgumentError]
  #
  # source://webmock-3.16.0/lib/webmock/request_stub.rb:27
  def to_return_json(*response_hashes); end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:93
  def to_s; end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:54
  def to_timeout; end

  # source://webmock-3.16.0/lib/webmock/request_stub.rb:12
  def with(params = T.unsafe(nil), &block); end

  class << self
    # source://webmock-3.16.0/lib/webmock/request_stub.rb:97
    def from_request_signature(signature); end
  end
end

# source://webmock-3.16.0/lib/webmock/response.rb:15
class WebMock::Response
  # @return [Response] a new instance of Response
  #
  # source://webmock-3.16.0/lib/webmock/response.rb:16
  def initialize(options = T.unsafe(nil)); end

  # source://webmock-3.16.0/lib/webmock/response.rb:92
  def ==(other); end

  # source://webmock-3.16.0/lib/webmock/response.rb:35
  def body; end

  # source://webmock-3.16.0/lib/webmock/response.rb:39
  def body=(body); end

  # source://webmock-3.16.0/lib/webmock/response.rb:83
  def evaluate(request_signature); end

  # source://webmock-3.16.0/lib/webmock/response.rb:53
  def exception; end

  # source://webmock-3.16.0/lib/webmock/response.rb:57
  def exception=(exception); end

  # source://webmock-3.16.0/lib/webmock/response.rb:24
  def headers; end

  # source://webmock-3.16.0/lib/webmock/response.rb:28
  def headers=(headers); end

  # source://webmock-3.16.0/lib/webmock/response.rb:73
  def options=(options); end

  # @raise [@exception]
  #
  # source://webmock-3.16.0/lib/webmock/response.rb:65
  def raise_error_if_any; end

  # source://webmock-3.16.0/lib/webmock/response.rb:69
  def should_timeout; end

  # source://webmock-3.16.0/lib/webmock/response.rb:45
  def status; end

  # source://webmock-3.16.0/lib/webmock/response.rb:49
  def status=(status); end

  private

  # source://webmock-3.16.0/lib/webmock/response.rb:110
  def assert_valid_body!; end

  # source://webmock-3.16.0/lib/webmock/response.rb:123
  def read_raw_response(raw_response); end

  # source://webmock-3.16.0/lib/webmock/response.rb:102
  def stringify_body!; end
end

# source://webmock-3.16.0/lib/webmock/response.rb:143
class WebMock::Response::InvalidBody < ::StandardError; end

# source://webmock-3.16.0/lib/webmock/response.rb:5
class WebMock::ResponseFactory
  class << self
    # source://webmock-3.16.0/lib/webmock/response.rb:6
    def response_for(options); end
  end
end

# source://webmock-3.16.0/lib/webmock/responses_sequence.rb:3
class WebMock::ResponsesSequence
  # @return [ResponsesSequence] a new instance of ResponsesSequence
  #
  # source://webmock-3.16.0/lib/webmock/responses_sequence.rb:7
  def initialize(responses); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/responses_sequence.rb:13
  def end?; end

  # source://webmock-3.16.0/lib/webmock/responses_sequence.rb:17
  def next_response; end

  # Returns the value of attribute times_to_repeat.
  #
  # source://webmock-3.16.0/lib/webmock/responses_sequence.rb:5
  def times_to_repeat; end

  # Sets the attribute times_to_repeat
  #
  # @param value the value to set the attribute times_to_repeat to.
  #
  # source://webmock-3.16.0/lib/webmock/responses_sequence.rb:5
  def times_to_repeat=(_arg0); end

  private

  # source://webmock-3.16.0/lib/webmock/responses_sequence.rb:29
  def increase_position; end
end

# source://webmock-3.16.0/lib/webmock/stub_registry.rb:3
class WebMock::StubRegistry
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [StubRegistry] a new instance of StubRegistry
  #
  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:8
  def initialize; end

  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:12
  def global_stubs; end

  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:20
  def register_global_stub(order = T.unsafe(nil), &block); end

  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:48
  def register_request_stub(stub); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:59
  def registered_request?(request_signature); end

  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:53
  def remove_request_stub(stub); end

  # Returns the value of attribute request_stubs.
  #
  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:6
  def request_stubs; end

  # Sets the attribute request_stubs
  #
  # @param value the value to set the attribute request_stubs to.
  #
  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:6
  def request_stubs=(_arg0); end

  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:16
  def reset!; end

  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:63
  def response_for_request(request_signature); end

  private

  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:77
  def evaluate_response_for_request(response, request_signature); end

  # source://webmock-3.16.0/lib/webmock/stub_registry.rb:70
  def request_stub_for(request_signature); end
end

# source://webmock-3.16.0/lib/webmock/stub_request_snippet.rb:2
class WebMock::StubRequestSnippet
  # @return [StubRequestSnippet] a new instance of StubRequestSnippet
  #
  # source://webmock-3.16.0/lib/webmock/stub_request_snippet.rb:3
  def initialize(request_stub); end

  # source://webmock-3.16.0/lib/webmock/stub_request_snippet.rb:7
  def body_pattern; end

  # source://webmock-3.16.0/lib/webmock/stub_request_snippet.rb:11
  def to_s(with_response = T.unsafe(nil)); end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:175
class WebMock::URIAddressablePattern < ::WebMock::URIPattern
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:176
  def add_query_params(query_params); end

  private

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:201
  def matches_with_variations?(uri); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:197
  def pattern_inspect; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:187
  def pattern_matches?(uri); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:213
  def template_matches_uri?(template, uri); end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:159
class WebMock::URICallablePattern < ::WebMock::URIPattern
  private

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:162
  def pattern_matches?(uri); end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:108
class WebMock::URIPattern
  include ::WebMock::RSpecMatcherDetector

  # @return [URIPattern] a new instance of URIPattern
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:111
  def initialize(pattern); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:123
  def add_query_params(query_params); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:138
  def matches?(uri); end

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:142
  def to_s; end

  private

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:150
  def pattern_inspect; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:154
  def query_params_matches?(uri); end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:167
class WebMock::URIRegexpPattern < ::WebMock::URIPattern
  private

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:170
  def pattern_matches?(uri); end
end

# source://webmock-3.16.0/lib/webmock/request_pattern.rb:220
class WebMock::URIStringPattern < ::WebMock::URIPattern
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:221
  def add_query_params(query_params); end

  private

  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:244
  def pattern_inspect; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/request_pattern.rb:232
  def pattern_matches?(uri); end
end

# source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:1
module WebMock::Util; end

# source://webmock-3.16.0/lib/webmock/util/hash_counter.rb:5
class WebMock::Util::HashCounter
  # @return [HashCounter] a new instance of HashCounter
  #
  # source://webmock-3.16.0/lib/webmock/util/hash_counter.rb:7
  def initialize; end

  # source://webmock-3.16.0/lib/webmock/util/hash_counter.rb:32
  def each(&block); end

  # source://webmock-3.16.0/lib/webmock/util/hash_counter.rb:19
  def get(key); end

  # Returns the value of attribute hash.
  #
  # source://webmock-3.16.0/lib/webmock/util/hash_counter.rb:6
  def hash; end

  # Sets the attribute hash
  #
  # @param value the value to set the attribute hash to.
  #
  # source://webmock-3.16.0/lib/webmock/util/hash_counter.rb:6
  def hash=(_arg0); end

  # source://webmock-3.16.0/lib/webmock/util/hash_counter.rb:13
  def put(key, num = T.unsafe(nil)); end

  # source://webmock-3.16.0/lib/webmock/util/hash_counter.rb:25
  def select(&block); end
end

# source://webmock-3.16.0/lib/webmock/util/hash_keys_stringifier.rb:3
class WebMock::Util::HashKeysStringifier
  class << self
    # source://webmock-3.16.0/lib/webmock/util/hash_keys_stringifier.rb:5
    def stringify_keys!(arg, options = T.unsafe(nil)); end
  end
end

# source://webmock-3.16.0/lib/webmock/util/headers.rb:7
class WebMock::Util::Headers
  class << self
    # source://webmock-3.16.0/lib/webmock/util/headers.rb:56
    def basic_auth_header(*credentials); end

    # source://webmock-3.16.0/lib/webmock/util/headers.rb:52
    def decode_userinfo_from_header(header); end

    # source://webmock-3.16.0/lib/webmock/util/headers.rb:9
    def normalize_headers(headers); end

    # source://webmock-3.16.0/lib/webmock/util/headers.rb:37
    def pp_headers_string(headers); end

    # source://webmock-3.16.0/lib/webmock/util/headers.rb:23
    def sorted_headers_string(headers); end
  end
end

# source://webmock-3.16.0/lib/webmock/util/json.rb:10
class WebMock::Util::JSON
  class << self
    # Ensure that ":" and "," are always followed by a space
    #
    # source://webmock-3.16.0/lib/webmock/util/json.rb:26
    def convert_json_to_yaml(json); end

    # source://webmock-3.16.0/lib/webmock/util/json.rb:13
    def parse(json); end

    # source://webmock-3.16.0/lib/webmock/util/json.rb:21
    def unescape(str); end
  end
end

# source://webmock-3.16.0/lib/webmock/util/json.rb:11
class WebMock::Util::JSON::ParseError < ::StandardError; end

# source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:2
class WebMock::Util::QueryMapper
  class << self
    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:79
    def collect_query_hash(query_array, empty_accumulator, options); end

    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:72
    def collect_query_parts(query); end

    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:219
    def dehash(hash); end

    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:104
    def fill_accumulator_for_dot(accumulator, key, value); end

    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:93
    def fill_accumulator_for_flat(accumulator, key, value); end

    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:100
    def fill_accumulator_for_flat_array(accumulator, key, value); end

    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:123
    def fill_accumulator_for_subscript(accumulator, key, value); end

    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:61
    def normalize_query_hash(query_hash, empty_accumulator, options); end

    # Converts the query component to a Hash value.
    #
    # @example
    #   WebMock::Util::QueryMapper.query_to_values("?one=1&two=2&three=3")
    #   #=> {"one" => "1", "two" => "2", "three" => "3"}
    #   WebMock::Util::QueryMapper("?one[two][three]=four").query_values
    #   #=> {"one" => {"two" => {"three" => "four"}}}
    #   WebMock::Util::QueryMapper.query_to_values("?one.two.three=four",
    #   :notation => :dot
    #   )
    #   #=> {"one" => {"two" => {"three" => "four"}}}
    #   WebMock::Util::QueryMapper.query_to_values("?one[two][three]=four",
    #   :notation => :flat
    #   )
    #   #=> {"one[two][three]" => "four"}
    #   WebMock::Util::QueryMapper.query_to_values("?one.two.three=four",
    #   :notation => :flat
    #   )
    #   #=> {"one.two.three" => "four"}
    #   WebMock::Util::QueryMapper(
    #   "?one[two][three][]=four&one[two][three][]=five"
    #   )
    #   #=> {"one" => {"two" => {"three" => ["four", "five"]}}}
    #   WebMock::Util::QueryMapper.query_to_values(
    #   "?one=two&one=three").query_values(:notation => :flat_array)
    #   #=> [['one', 'two'], ['one', 'three']]
    # @option [Symbol]
    # @param [Symbol] [Hash] a customizable set of options
    # @return [Hash, Array] The query string parsed as a Hash or Array object.
    #
    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:40
    def query_to_values(query, options = T.unsafe(nil)); end

    # new_query_values have form [['key1', 'value1'], ['key2', 'value2']]
    #
    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:245
    def to_query(parent, value, options = T.unsafe(nil)); end

    # Sets the query component for this URI from a Hash object.
    # This method produces a query string using the :subscript notation.
    # An empty Hash will result in a nil query.
    #
    # @param new_query_values [Hash, #to_hash, Array] The new query values.
    #
    # source://webmock-3.16.0/lib/webmock/util/query_mapper.rb:177
    def values_to_query(new_query_values, options = T.unsafe(nil)); end
  end
end

# source://webmock-3.16.0/lib/webmock/util/uri.rb:5
class WebMock::Util::URI
  class << self
    # source://webmock-3.16.0/lib/webmock/util/uri.rb:65
    def encode_unsafe_chars_in_userinfo(userinfo); end

    # source://webmock-3.16.0/lib/webmock/util/uri.rb:26
    def heuristic_parse(uri); end

    # @return [Boolean]
    #
    # source://webmock-3.16.0/lib/webmock/util/uri.rb:69
    def is_uri_localhost?(uri); end

    # source://webmock-3.16.0/lib/webmock/util/uri.rb:30
    def normalize_uri(uri); end

    # source://webmock-3.16.0/lib/webmock/util/uri.rb:76
    def sort_query_values(query_values); end

    # source://webmock-3.16.0/lib/webmock/util/uri.rb:57
    def strip_default_port_from_uri_string(uri_string); end

    # source://webmock-3.16.0/lib/webmock/util/uri.rb:87
    def uris_encoded_and_unencoded(uris); end

    # source://webmock-3.16.0/lib/webmock/util/uri.rb:81
    def uris_with_inferred_port_and_without(uris); end

    # source://webmock-3.16.0/lib/webmock/util/uri.rb:96
    def uris_with_scheme_and_without(uris); end

    # source://webmock-3.16.0/lib/webmock/util/uri.rb:102
    def uris_with_trailing_slash_and_without(uris); end

    # source://webmock-3.16.0/lib/webmock/util/uri.rb:36
    def variations_of_uri_as_strings(uri_object, only_with_scheme: T.unsafe(nil)); end
  end
end

# source://webmock-3.16.0/lib/webmock/util/uri.rb:10
WebMock::Util::URI::ADDRESSABLE_URIS = T.let(T.unsafe(nil), Hash)

# source://webmock-3.16.0/lib/webmock/util/uri.rb:6
module WebMock::Util::URI::CharacterClasses; end

# source://webmock-3.16.0/lib/webmock/util/uri.rb:7
WebMock::Util::URI::CharacterClasses::USERINFO = T.let(T.unsafe(nil), String)

# source://webmock-3.16.0/lib/webmock/util/uri.rb:14
WebMock::Util::URI::NORMALIZED_URIS = T.let(T.unsafe(nil), Hash)

# source://webmock-3.16.0/lib/webmock/util/values_stringifier.rb:1
class WebMock::Util::ValuesStringifier
  class << self
    # source://webmock-3.16.0/lib/webmock/util/values_stringifier.rb:2
    def stringify_values(value); end
  end
end

# source://webmock-3.16.0/lib/webmock/version.rb:2
WebMock::VERSION = T.let(T.unsafe(nil), String)

# source://webmock-3.16.0/lib/webmock/util/version_checker.rb:26
class WebMock::VersionChecker
  # @return [VersionChecker] a new instance of VersionChecker
  #
  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:27
  def initialize(library_name, library_version, min_patch_level, max_minor_version = T.unsafe(nil), unsupported_versions = T.unsafe(nil)); end

  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:43
  def check_version!; end

  private

  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:107
  def colorize(text, color_code); end

  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:84
  def compare_version; end

  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:103
  def parse_version(version); end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:55
  def too_high?; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:51
  def too_low?; end

  # @return [Boolean]
  #
  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:59
  def unsupported_version?; end

  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:96
  def version_requirement; end

  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:68
  def warn_about_too_high; end

  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:63
  def warn_about_too_low; end

  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:74
  def warn_about_unsupported_version; end

  # source://webmock-3.16.0/lib/webmock/util/version_checker.rb:80
  def warn_in_red(text); end
end
